<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[破船之家]]></title>
  <subtitle><![CDATA[去留无意，漫随天外云卷云舒]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://beyondvincent.com/"/>
  <updated>2015-10-21T05:15:15.337Z</updated>
  <id>http://beyondvincent.com/</id>
  
  <author>
    <name><![CDATA[破船之家]]></name>
    <email><![CDATA[BeyondVincent@gmail.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[watchOS 2]]></title>
    <link href="http://beyondvincent.com/2015/10/16/2015-10-16-watchkit-for-watchos-2/"/>
    <id>http://beyondvincent.com/2015/10/16/2015-10-16-watchkit-for-watchos-2/</id>
    <published>2015-10-16T15:38:00.000Z</published>
    <updated>2015-10-21T05:11:28.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7u2mu6.com1.z0.glb.clouddn.com/watchOS2.png" alt=""></p>
<a id="more"></a>

<h2 id="花絮">花絮</h2>
<p>话说今年我只写了一篇文章，还是年初 1 月份的时候了（<a href="http://beyondvincent.com/2015/01/20/2015-01-20-Apple-Watch/" target="_blank" rel="external">Apple Watch: WatchKit 应用程序要点</a>），其实我一直都想写一些文章出来，但是一直没有码字发文，主要是由于我太懒。坑倒是挖了不少，包括 watchOS 2、持续集成等相关的文章（Java Web、iOS 和 Android 方面的）等。可能后面我会先填一些坑。</p>
<p><code>有些东西放下的时间久了，就会慢慢的忘却，这是多么令人沮丧的事情。</code></p>
<p>今天就先来谈谈关于 watchOS 2 的一些东西吧。</p>
<h2 id="watchOS_2">watchOS 2</h2>
<p>苹果早在 2015 年 6 月 9 日，就向开发者发布了 <a href="https://developer.apple.com/watchos/`" target="_blank" rel="external"><code>watchOS 2</code></a>，目前消费者可以下载使用了，（奇怪的是前几天看官网还是显示 prerelease，不过现在已经是 release 了）。</p>
<p><img src="http://7u2mu6.com1.z0.glb.clouddn.com/QQ20151017-1.png" alt="image"></p>
<p>苹果在推出 Apple Watch 之初，实际上是饱受争议的，即使现在，各种争议也不少。有的不看好 Apple Watch，说它的续航能力是最大的软肋，而有的人又认为它的屏幕限制了 Apple Watch 的应用场景，吧啦吧啦，反正是各种吐槽。而另外一群人则非常看好 Apple Watch 的前景，并相信 Apple Watch 如同苹果在 2007 年发布的 iPhone 一样，会再次改变世界。</p>
<p>就我个人而言，我还是比较看好 Apple Watch 的，通过如下 2 个场景，你就会发现 Apple Watch 非常实用：</p>
<ul>
<li>支付场景：你去超市购物，到收银台结算的时候，传统的方式为付现或者刷卡，有部分人群可能会用手机支付软件，进行扫码支付。不过，这还不是最优付费方式，即使用手机支付，也需要将手机从兜里面掏出来。如果使用 Apple Watch 的话，那么只需要抬起手腕，打开支付 App 就可以进行支付，这不是神话，使用 Apple Watch 确实可以做到，并且已经做到了。</li>
<li>运动场景：经常跑步的人们在跑步过程中，经常需要做计时、速度、距离等运动数据的统计，并实时反馈，一般人们用手机上的运动软件比较多，每次看速度、时间等都是从兜里面掏出手机，然后解锁屏幕，再看相关运动数据。虽说现在的许多手机软件有语音之类的提醒，但用户体验并不是很好，谁用谁知道。如果用户使用了 Apple Watch，那么想要看运动数据的时候，只需要抬起手腕，就可以查看相关数据，非常方便。</li>
</ul>
<p>当然，还有很多应用场景在 Apple Watch 上都能带来绝佳的体验，例如提醒类应用（天气预报、来电提醒、用药提醒）、健康类应用（实时反馈个人身体健康数据）等，在这里就不一一罗列了。</p>
<h2 id="WatchKit_架构变化">WatchKit 架构变化</h2>
<p>在 watchOS 1 做过开发的人，都应该熟悉如下这张图：</p>
<p><img src="http://7u2mu6.com1.z0.glb.clouddn.com/QQ20151017-4.png" alt="image"></p>
<p>如上图所示，在 watchOS 1 上面做开发，Apple Watch 应用程序由两部分构成：Watch App 和 WatchKit 扩展。</p>
<ul>
<li>Watch App 是一个运行在 Apple Watch 中的可执行文件。它包括 storyboard 和渲染屏幕时所需的资源文件。</li>
<li><p>WatchKit 扩展则是运行在 iPhone 上的可执行文件。包括管理应用程序界面的逻辑代码，以及处理用户的交互操作。</p>
<p>想要了解 watchOS 1 中更详细的内容，可以看我博客上的这篇文章：<a href="http://beyondvincent.com/2015/01/20/2015-01-20-Apple-Watch/" target="_blank" rel="external">Apple Watch: WatchKit 应用程序要点</a>）。</p>
<p>那么，在 watchOS 2 中，WatchKit 的架构发生了比较重大的变化，我们先来看看下面这张图：</p>
<p><img src="http://7u2mu6.com1.z0.glb.clouddn.com/QQ20151017-5.png" alt="image"></p>
</li>
</ul>
<p>从上面的图中，可以很明显地看出，苹果把原来运行在 iPhone 手机上的 WatchKit Extension 移到 Apple Watch 中了。这将直接带来如下改变：原来只存放一些资源和 Storyboard 的 Watch App，现在程序的业务逻辑部分（也就是代码执行部分）也被放到 Watch App 中。这样的话，程序给用户的体验会更好，Watch App 的运行可以完全独立于 iPhone 了。值得注意的是，Apple Watch 2 中还支持 WiFi，所以 Apple Watch 可以通过 WiFi，直接获取一些网络数据等。并且 Apple Watch 无法处理的一些业务，可以通过 Connectivity 框架，请求 iPhone 进行处理，并将结果返回给 Apple Watch。</p>
<p><img src="http://7u2mu6.com1.z0.glb.clouddn.com/QQ20151017-3.png" alt="image"></p>
<p>另外，在 watchOS 2 中，有更多的权限可以对硬件资源进行访问，例如麦克风，加速器和表冠等。这也给我们开发人员在开发的时候带来了无限想象，无限可能。</p>
<p>其实 watchOS 2 中带来了许多改进，这里就不进行详细的介绍，大家如果感兴趣的话可以查阅本文最后提供的一些参考资料。</p>
<h2 id="开发者需要注意的一些事情">开发者需要注意的一些事情</h2>
<p><img src="http://7u2mu6.com1.z0.glb.clouddn.com/QQ20151017-0.png" alt="image"></p>
<p>其实用过 watchOS 2 中的 WatchKit，会发现，对于开发者来说，就 Xcode 的工程结构而言，开发编码上没有太大的变化。苹果虽然对框架做了重大的调整，但是也考虑了开发者的跟进成本，开发者跟 watchOS 1 中的开发基本一样，WatchKit App 中依旧是存放资源和 Storyboard，而 WatchKit Extension 中还是做相关业务逻辑的编码。</p>
<pre><code>    所以开发者在跟进 watchOS 上对于框架上来说只需要理解各个模块是运作原理，然后编码还是原来的味道，熟悉的味道。
</code></pre><p>当然，开发者在进行 watchOS 2 开发或迁移时，还有一些需要注意的地方:</p>
<ul>
<li>关于迁移到 watchOS 2 上的开发，可以看看苹果官网提供的内容：<a href="https://developer.apple.com/library/watchos/documentation/General/Conceptual/AppleWatch2TransitionGuide/index.html" target="_blank" rel="external"><code>watchOS 2 Transition Guide</code></a> 。另外来自 <code>springxiao</code> 的这篇文章（巧哥的微信公众号上面曾经转载过）也提及了一些开发注意事项，值得一读：<a href="http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&amp;mid=208847424&amp;idx=1&amp;sn=fac57c5da8136b07fe9cdf53d1ec9f4c&amp;scene=4#wechat_redirect" target="_blank" rel="external"><code>Watch OS2.0开发概述</code></a> 。</li>
</ul>
<p><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&amp;mid=208847424&amp;idx=1&amp;sn=fac57c5da8136b07fe9cdf53d1ec9f4c&amp;scene=4#wechat_redirect" target="_blank" rel="external">http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&amp;mid=208847424&amp;idx=1&amp;sn=fac57c5da8136b07fe9cdf53d1ec9f4c&amp;scene=4#wechat_redirect</a></p>
<h2 id="关于译书">关于译书</h2>
<p>在今年夏季有幸与电子工业出版社的编辑合作，翻译了一本关于 Apple Watch 开发的书，书原名为 <code>Learning WatchKit Programming- A Hands-On Guide to Creating Apple Watch Applications</code>，中文名称为《从iOS到Apple Watch：用WatchKit创建新型可穿戴应用》，在京东，当当，亚马逊有售。此书是基于 watchOS 1 编写的，因为是引进的书我没有修改权，内容并未更新至 watchOS 2，大家在购买时自行考虑。不过我个人对于 watchOS 2 还是有一些研究的，如果大家购买之后有什么疑问，可以微博（BeyondVincent）上私信我，我会尽力解答。若实在对书质量不满，支持退货。</p>
<p><img src="http://7u2mu6.com1.z0.glb.clouddn.com/1295993663-1_u_1.jpg" alt="image"></p>
<h2 id="一些参考资料">一些参考资料</h2>
<ul>
<li><a href="https://developer.apple.com/library/watchos/documentation/General/Conceptual/AppleWatch2TransitionGuide/index.html" target="_blank" rel="external"><code>watchOS 2 Transition Guide</code></a> : watchOS 2 迁移指南</li>
<li><a href="https://developer.apple.com/library/watchos/documentation/General/Conceptual/WatchKitProgrammingGuide/DesigningaWatchKitApp.html" target="_blank" rel="external"><code>WatchKit Programming Guide</code></a> : WatchKit 编程指南</li>
<li><a href="https://developer.apple.com/watch/human-interface-guidelines/" target="_blank" rel="external"><code>Apple Watch Human Interface Guidelines</code></a> : Apple Watch 人机交互指南</li>
<li></li>
</ul>
<h2 id="小结">小结</h2>
<p>经过几年的发展，智能机目前的出货率很难复制前几年了，大家也可以看出，各大手机厂家不仅仅是在做手机了，都在抓紧发展自己的生态圈。虽然到处都是风口，但是真正能抓住消费者的产品不是一簇而就的。当下可穿戴设备被无限放大，或许等退潮之后，才知道是谁在裸泳。</p>
<p>以上是我对 watchOS 2 的一些理解，如有不对的地方，欢迎大家拍砖。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://7u2mu6.com1.z0.glb.clouddn.com/watchOS2.png" alt=""></p>
]]>
    
    </summary>
    
      <category term="WatchKit" scheme="http://beyondvincent.com/categories/WatchKit/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Apple Watch: WatchKit 应用程序要点]]></title>
    <link href="http://beyondvincent.com/2015/01/20/2015-01-20-Apple-Watch/"/>
    <id>http://beyondvincent.com/2015/01/20/2015-01-20-Apple-Watch/</id>
    <published>2015-01-20T05:39:00.000Z</published>
    <updated>2015-01-21T05:08:39.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7u2mu6.com1.z0.glb.clouddn.com/Banner_WatchKit App Essentials.png" alt=""></p>
<a id="more"></a>

<p>本文译自：<a href="http://www.chupamobile.com/blog/category/ios/apple-watch/" target="_blank" rel="external">Apple Watch: WatchKit App Essentials</a></p>
<h2 id="WatchKit_应用程序架构">WatchKit 应用程序架构</h2>
<p>上一篇文章简单介绍了 WatchKit，在开发 Apple Watch 应用程序时由两部分构成：WatchKit 应用程序和 WatchKit 扩展。</p>
<ul>
<li><code>WatchKit 应用程序</code>是一个运行在 Apple Watch 中的可执行文件。它包括 storyboard 和渲染屏幕时所需的资源文件。</li>
<li><code>WatchKit 扩展</code>则是运行在 iPhone 上的可执行文件。包括管理应用程序界面的逻辑代码，以及处理用户的交互操作。</li>
</ul>
<p>为了程序界面的正常使用，这两部分需要一起运行。用户与应用程序交互的典型步骤如下：</p>
<ol>
<li>用户与 WatchKit 应用程序交互。</li>
<li>WatchKit 应用程序分析交互情况，并选择将被管理的 storyboard。</li>
<li>WatchKit 与 iPhone 通讯，以运行 WatchKit 扩展。</li>
<li>WatchKit 扩展初始化并创建需要提供给 WatchKit 应用程序 storyboard 使用的对象。</li>
<li>Storyboard 根据 WatchKit 扩展创建的对象，生成 scene，并将其显示到 Apple Watch 中。</li>
<li>WatchKit 应用程序和 WatchKit 将会共享一些信息，直到用户停止使用 WatchKit 应用程序。此时，iOS 将使 WatchKit 扩展休眠，直到有新的用户交互。</li>
</ol>
<p>下面的这个图演示了这个流程：</p>
<p><img src="http://7u2mu6.com1.z0.glb.clouddn.com/WatchKit-app-architecture.png" alt=""></p>
<p>上图中有个重要的概念就是 storyboard 响应用户的操作并配置需要显示的屏幕内容的方法。这归功于 <code>interface controller</code>对象 (<code>WKInterfaceController</code>的实例)，相当于 iOS 中的 view controller。</p>
<p>与 view controller 不同的是 interface controller 不管理屏幕中实际的 view，WatchKit 以透明的方式对 view 进行处理。一般，一个 WatchKit 应用程序会有多个 interface controller，用来显示不同的数据类型，只不过同时只显示一个罢了。</p>
<h2 id="WatchKit_应用程序的生命周期">WatchKit 应用程序的生命周期</h2>
<p>一个 WatchKit 应用程序的启动方式有 3 种：</p>
<ul>
<li>用户点击 Apple Watch 主屏幕上的图标。</li>
<li>用户与应用程序的 glance 交互。</li>
<li>用户与通知交互。</li>
</ul>
<p>上面的每种方式都将初始化 WatchKit 应用程序和 WatchKit 扩展。根据上面不同的启动方式，WatchKit 会利用相应的 storyboard 加载 scene，并请求 WatchKit 扩展初始化相应的 interface controller。</p>
<p>下面的图演示了相关过程：</p>
<p><img src="http://7u2mu6.com1.z0.glb.clouddn.com/Interface-controller-lifecycle.png.png" alt=""></p>
<p>如图所示，在用户界面中，interface controller 对象管理着相关交互。当用户与 Apple Watch 上的应用程序交互时，WatchKit 扩展会运行。一旦用户停止交互或者从程序中退出，iOS 将关闭当前的 interface controller，并休眠扩展。在用户和 Apple Watch 之间，这样的交互方式非常简洁，interface controller 应该是轻量级的，并且快速的执行任务。</p>
<p>下面的图演示了相关过程：</p>
<p><img src="http://7u2mu6.com1.z0.glb.clouddn.com/442x174xInterface-controller-lifecycle.png.pagespeed.ic.HpuKT10ZdT.png.png" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://7u2mu6.com1.z0.glb.clouddn.com/Banner_WatchKit App Essentials.png" alt=""></p>
]]>
    
    </summary>
    
      <category term="WatchKit" scheme="http://beyondvincent.com/categories/WatchKit/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[WatchKit 框架: 将应用程序从裤兜里取出来]]></title>
    <link href="http://beyondvincent.com/2015/01/20/2015-01-20-watchkit-framework-taking-apps-pocket/"/>
    <id>http://beyondvincent.com/2015/01/20/2015-01-20-watchkit-framework-taking-apps-pocket/</id>
    <published>2015-01-20T05:38:00.000Z</published>
    <updated>2015-01-21T05:08:50.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7u2mu6.com1.z0.glb.clouddn.com/Banner_Taking Apps Out Of Your Pocket.png" alt=""></p>
<a id="more"></a>

<p>本文译自：<a href="http://www.chupamobile.com/blog/2014/12/03/watchkit-framework-taking-apps-pocket/" target="_blank" rel="external">WatchKit Framework: Taking Apps Out Of Your Pocket</a></p>
<p>你是否已经厌倦了总是需要将 iPhone 从裤兜里取出来才能查看消息？你希望像 Michael knight 一样，通过手腕就能与朋友通话吗？苹果已经让其变得可能：全新的 Apple Watch 和非常酷的 WatchKit 框架。</p>
<p><img src="http://7u2mu6.com1.z0.glb.clouddn.com/600x308xWatchKit.png.pagespeed.ic.sKr7LqrofT.png" alt=""></p>
<p>在为 Apple Watch 开发应用程序（也称为<code>Watch 应用程序</code>）时，开发者需要清晰的知道，目前<code>Watch 应用程序</code>需要一个运行在 iPhone 上的应用程序。因此，需要有两个可执行文件：</p>
<ul>
<li><code>Watch 应用程序</code>将运行在 Apple Watch 中，里面包括 storyboard，以及在应用程序界面渲染中需要用到的资源文件。</li>
<li><code>WatchKit 扩展</code>将运行在 iPhone 中，包括管理应用程序界面的逻辑代码，以及处理用户的交互操作。</li>
</ul>
<p>当开发一个 Apple Watch 应用程序时，在 storyboard 中的每个 scene 都需要对应的创建一个 <code>WKInterfaceController</code>。这个类有2个重要的方法：<code>initWithContext</code> 和 <code>willActivate</code>，它们负责获取需要显示的数据，以及初始化并配置可视化模块，例如按钮或文字标签。</p>
<p>如果需要创建一个 view 来显示收到的信息（例如收到一条 iMessage 通知，邀请你吃午饭，界面中有按钮需要你来接受或者拒绝邀请。），此时需要实例化一个 <code>WKUserNotificationInterfaceController</code>，该类继承自 <code>WKInterfaceController</code>。</p>
<p>在上面的 interface control 类中，还有另外一些有意思的方法：</p>
<ul>
<li><code>presentTextInputControllerWithSuggestions:completion:</code>这个方法的作用是在屏幕中以模态的方式给用户显示一个文本输入界面——通过让用户选择给出的建议文字。</li>
<li><code>updateUserActivity:userInfo:</code>获得当前应用程序的 activity（例如用户在屏幕中做了一下 tab 操作），并将其报告给用户的 iPhone，以进行相关的处理。</li>
</ul>
<p>在 Watch 应用程序中，有一个重要的概念就是 <code>glances</code>。其实 <code>glances</code> 就是应用程序中一种特殊的界面，用来向用户显示特定的信息，它的特殊性就在于其无法滚动，并且是只读的。这也是为什么 glance 不能包含 UI 组件的缘故，例如按钮，文本输入框或滑块。</p>
<p>在 WatchKit 中，我们可以发现有 <code>WKInterfaceDevice</code>，该类包含 Apple Watch 中的用户配置相关信息。通过该类，我们可以获取相关信息，与用户账号相关联，并显示到程序中。</p>
<p>该类另外一个重要的作用就是在 Apple Watch 上缓存图片，这样在将来可以使用这些缓存图片，以此避免每次都需要创建这些图片，进而降低了程序的性能。</p>
<p>该类的一些方法如下：</p>
<ul>
<li><code>preferredContentSizeCategory:</code>获取有用户自定义的字体大小。这个方法对于辅助-驱动的应用程序非常重要。</li>
<li><code>addCachedImage:name:</code>将传入的图片添加至设备的缓存中。</li>
<li><code>removeCacheImageWithName:</code>移除之前缓存的图片。</li>
</ul>
<p>最后，WatchKit 引入了几个 interface object 进行界面的构建，这是 UIKit 的定制版本。例如 <code>WKInterfaceButton</code>, <code>WKInterfaceDate</code>, <code>WKInterfaceImage</code>, <code>WKInterfaceLabel</code>, <code>WKInterfaceMap</code>, <code>WKInterfaceSlider</code>, 和 <code>WKInterfaceSwitch</code>等。</p>
<p>说句实话，我还没有戴过 Apple Watch，但可以肯定的是，这将意味着新技术的革命，期待吧！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://7u2mu6.com1.z0.glb.clouddn.com/Banner_Taking Apps Out Of Your Pocket.png" alt=""></p>
]]>
    
    </summary>
    
      <category term="WatchKit" scheme="http://beyondvincent.com/categories/WatchKit/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello World - HEXO]]></title>
    <link href="http://beyondvincent.com/2015/01/20/hello-world/"/>
    <id>http://beyondvincent.com/2015/01/20/hello-world/</id>
    <published>2015-01-20T01:38:00.000Z</published>
    <updated>2015-01-30T18:28:56.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7u2mu6.com1.z0.glb.clouddn.com/hexo-logo.png" alt=""><br><a id="more"></a></p>
<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">trobuleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start">Quick Start</h2>
<h3 id="Create_a_new_post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://7u2mu6.com1.z0.glb.clouddn.com/hexo-logo.png" alt=""><br>]]>
    
    </summary>
    
      <category term="杂集" scheme="http://beyondvincent.com/categories/%E6%9D%82%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[UIKit Dynamics 教程：抛掷 Views]]></title>
    <link href="http://beyondvincent.com/2014/09/02/2014-09-02-uikit-dynamics-tutorial-tossing-views/"/>
    <id>http://beyondvincent.com/2014/09/02/2014-09-02-uikit-dynamics-tutorial-tossing-views/</id>
    <published>2014-09-01T17:15:00.000Z</published>
    <updated>2014-12-31T19:05:45.000Z</updated>
    <content type="html"><![CDATA[<p><img src="/images/2014/09/01.png" alt=""></p>
<a id="more"></a>

<p>本文译自：<a href="http://www.raywenderlich.com/71828/uikit-dynamics-tutorial-tossing-views" target="_blank" rel="external">UIKit Dynamics Tutorial: Tossing Views</a></p>
<p>本文中，我们将学习如何用手势很自然的将 view 抛掷出屏幕。</p>
<p>可能你已经看到该技术在 <a href="https://itunes.apple.com/us/app/tweetbot-3-for-twitter-iphone/id722294701?uo=8&amp;at=11ld4k" target="_blank" rel="external">Tweetbot</a> 中的流行了。</p>
<p>本文非常适合中级开发者，因为对 view 抛掷操作中，使用的技术嵌套了多个效果，例如使用内置的 UIKit 框架对 view 进行旋转 (rotation)、飞离 (fly-away) 动画。</p>
<p>如果你之前还不了解 UIKit dynamics，也不用担心 - 本文会一步一步的引导你进行学习。</p>
<p>事不宜迟，我们开始抛掷 view 吧！</p>
<p>目录：</p>
<ul>
<li><a href="#Getting_Started">开始</a></li>
<li><a href="#UIDynamicAnimator_and_UIAttachmentBehavior">UIDynamicAnimator 和 UIAttachmentBehavior</a></li>
<li><a href="#UIPushBehavior">UIPushBehavior</a></li>
<li><a href="#Where_To_Go_From_Here">何去何从？</a></li>
</ul>
<hr>
<p><a name="Getting_Started"></a></p>
<h2 id="开始">开始</h2>
<p>提醒：学习中，本节是可选的，主要是针对想要从零开始的读者。有经验的 iOS 开发者可以忽略本节，直接到下一节 (已经为你准备好一个工程了)。</p>
<p>打开 Xcode，选择 <code>File\New\Project…</code>，选择 <code>iOS\Application\Single View Application</code>模板，然后点击 <code>Next</code>。将工程命名为 <code>DynamicToss</code>，并将 device family 设置为 iPhone。</p>
<p>现在选中左边的工程名称，并确保选中 Xcode 窗口顶部的 General。在 <code>Deployment Info/Device Orientation</code> 中，不要勾选 ‘Landscape Left’ and ‘Landscape Right’，因为这个程序只以 portrait 模式运行。</p>
<p><img src="/images/2014/09/02.png" alt=""></p>
<p>接着下载一个<a href="http://cdn2.raywenderlich.com/wp-content/uploads/2014/05/flying_goldfish.zip" target="_blank" rel="external">图片</a>，这个图片来自<a href="http://www.vickiwenderlich.com/" target="_blank" rel="external">gameartguppy.com</a>：</p>
<p><img src="/images/2014/09/03.jpg" alt=""></p>
<p>将工程解压出来，然后将图片文件添加到工程中。</p>
<p>接着，打开 <code>Main.storyboard</code>，并添加一个 image view 控件，相关值设置为：(X=33, Y=137, Width=254, Height=172, Image=goldfish_feature.jpg)。现在屏幕上的看起来应该是这样的：</p>
<p><img src="/images/2014/09/04.png" alt=""></p>
<p>接着，拖两个 UIView 到 view controller 中，这两个 UIView 用来对手势进行跟踪。按照下面的值进行设置：</p>
<ul>
<li>View 1: (X=156, Y=219, Width=8, Height=8, Background=red)</li>
<li>View 2: (X=80, Y=420, Width=8, Height=8. Background=blue)</li>
</ul>
<p>至此，view 看起来应该是这样的：</p>
<p><img src="/images/2014/09/05.png" alt=""></p>
<p>将下面的私有属性添加到 <code>RWTViewController.m</code> 中：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *image;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *redSquare;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *blueSquare;</div><div class="line"> </div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGRect</span> originalBounds;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGPoint</span> originalCenter;</div><div class="line"> </div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) UIDynamicAnimator *animator;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) UIAttachmentBehavior *attachmentBehavior;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) UIPushBehavior *pushBehavior;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) UIDynamicItemBehavior *itemBehavior;</div></pre></td></tr></table></figure>

<p>选中 <code>Main.storyboard</code> 文件，并右键单击 <code>View Controller</code>。拖拽住出现的 <code>blueSquare</code> outlet，将其与蓝色正方形 view 连接上：这个动作会将属性连接至 view 对象。</p>
<p>同样也把红色正方形连接好，最后是名字位 <code>image</code> 的属性。现在 3 个 view 属性应该已经连接好了，看起来如下图所示：</p>
<p><img src="/images/2014/09/06.png" alt=""></p>
<p>红色和蓝色的正方形代表 UIDynamics 物理引擎对图像进行动画效果的点。</p>
<p>蓝色正方形简单的代表触摸的开始，例如，你的手指与屏幕第一次交互时的位置。红色的正方形用来跟踪手指的移动。</p>
<p>你需要对 UIDynamics 框架进行配置，以使得当移动点时，图片也跟着串联的方式做物理动画。</p>
<p>现在还有一件事件需要做 - 为 view 配置一个手势识别。打开 <code>RWTViewController.m</code>，将下面的方法添加到文件中：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">IBAction</span>) handleAttachmentGesture:(UIPanGestureRecognizer*)gesture</div><div class="line">{</div><div class="line">    <span class="built_in">CGPoint</span> location = [gesture locationInView:<span class="keyword">self</span><span class="variable">.view</span>];</div><div class="line">    <span class="built_in">CGPoint</span> boxLocation = [gesture locationInView:<span class="keyword">self</span><span class="variable">.image</span>];</div><div class="line"> </div><div class="line">    <span class="keyword">switch</span> (gesture<span class="variable">.state</span>) {</div><div class="line">    <span class="keyword">case</span> UIGestureRecognizerStateBegan:{</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"you touch started position %@"</span>,NSStringFromCGPoint(location));</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"location in image started is %@"</span>,NSStringFromCGPoint(boxLocation));</div><div class="line"> </div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    }</div><div class="line">    <span class="keyword">case</span> UIGestureRecognizerStateEnded: {</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"you touch ended position %@"</span>,NSStringFromCGPoint(location));</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"location in image ended is %@"</span>,NSStringFromCGPoint(boxLocation));</div><div class="line"> </div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    }</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>我们将要添加一个手势识别，来检测拖拽，也称为平移 (panning)，当事件发生时，会调用上面这个方法。目前，这个方法简单的显示出手指在两个不同坐标系空间 (view 和 image view) 的位置。</p>
<p>为了添加手势识别，打开 <code>Main.storyboard</code>，并拖一个 <code>Pan Gesture Recognizer</code> 到 view 中。然后从 <code>Pan Gesture Recognizer</code> control-drag 到我们的 <code>View Controller</code>，并将其连接到 <code>handleAttachmentGesture:</code> 方法上。</p>
<p>现在编译并运行程序。在屏幕上轻扫或者拖动，可以在控制台看到类似如下信息：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">2014</span>-<span class="number">07</span>-<span class="number">13</span> <span class="number">14</span>:<span class="number">01</span>:<span class="number">49.666</span> DynamicToss[<span class="number">3999</span>:<span class="number">60</span>b] you touch started position {<span class="number">127</span>, <span class="number">365</span>}</div><div class="line"><span class="number">2014</span>-<span class="number">07</span>-<span class="number">13</span> <span class="number">14</span>:<span class="number">01</span>:<span class="number">49.667</span> DynamicToss[<span class="number">3999</span>:<span class="number">60</span>b] location <span class="keyword">in</span> image started is {<span class="number">94</span>, <span class="number">228</span>}</div><div class="line"><span class="number">2014</span>-<span class="number">07</span>-<span class="number">13</span> <span class="number">14</span>:<span class="number">01</span>:<span class="number">50.097</span> DynamicToss[<span class="number">3999</span>:<span class="number">60</span>b] you touch ended position {<span class="number">113</span>, <span class="number">464</span>}</div><div class="line"><span class="number">2014</span>-<span class="number">07</span>-<span class="number">13</span> <span class="number">14</span>:<span class="number">01</span>:<span class="number">50.097</span> DynamicToss[<span class="number">3999</span>:<span class="number">60</span>b] location <span class="keyword">in</span> image ended is {<span class="number">80</span>, <span class="number">327</span>}</div></pre></td></tr></table></figure>

<p>非常棒！现在已经完成了基本的 UI 配置 - 接下来是时候开始 dynamic了！</p>
<p><a name="UIDynamicAnimator_and_UIAttachmentBehavior"></a></p>
<h2 id="UIDynamicAnimator_和_UIAttachmentBehavior">UIDynamicAnimator 和 UIAttachmentBehavior</h2>
<p>提醒：如果你忽略了上一章节的内容，请先从这里下载为你准备好的<a href="http://cdn2.raywenderlich.com/wp-content/uploads/2014/07/DynamicTossStarter2.zip" target="_blank" rel="external">工程</a>。</p>
<p>首先我们要做的事情就是让 image view 跟随我们的拖拽一起移动。这将通过 UIKit Dynamics中的 <code>UIAttachmentBehavior</code> 来实现。</p>
<p>打开 <code>RWTViewController.m</code>，并将下面的代码添加到 <code>viewDidLoad</code> 中，位于 <code>[super viewDidLoad]</code> 下方：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">self</span><span class="variable">.animator</span> = [[UIDynamicAnimator alloc] initWithReferenceView:<span class="keyword">self</span><span class="variable">.view</span>];</div><div class="line"><span class="keyword">self</span><span class="variable">.originalBounds</span> = <span class="keyword">self</span><span class="variable">.image</span><span class="variable">.bounds</span>;</div><div class="line"><span class="keyword">self</span><span class="variable">.originalCenter</span> = <span class="keyword">self</span><span class="variable">.image</span><span class="variable">.center</span>;</div></pre></td></tr></table></figure>

<p>上面的代码将配置一个 <code>UIDynamicAnimator</code>，这是 UIKit 中的一个引擎，用于支持最基本的物理动画效果。参照 <code>self.view</code> 定义了 animator 的坐标系。</p>
<p>通过给 animator 添加行为 (behaviors)，可以让你做一些事情，例如具有重力效果的进行 attaching view、pushing view等。</p>
<p>下面我们开始给 animator 添加第一个行为：<code>UIAttachmentBehavior</code> - 使得 image view 跟着手指的手势进行移动。</p>
<p>为了完成这样的效果，将下面的代码添加到 <code>handleAttachmentGesture:</code> 中，位于 <code>case UIGestureRecognizerStateBegan</code> 的两个 NSLog 语句下方：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1</span></div><div class="line">[<span class="keyword">self</span><span class="variable">.animator</span> removeAllBehaviors];</div><div class="line"> </div><div class="line"><span class="comment">// 2        </span></div><div class="line">UIOffset centerOffset = UIOffsetMake(boxLocation<span class="variable">.x</span> - CGRectGetMidX(<span class="keyword">self</span><span class="variable">.image</span><span class="variable">.bounds</span>),</div><div class="line">                                     boxLocation<span class="variable">.y</span> - CGRectGetMidY(<span class="keyword">self</span><span class="variable">.image</span><span class="variable">.bounds</span>));</div><div class="line"><span class="keyword">self</span><span class="variable">.attachmentBehavior</span> = [[UIAttachmentBehavior alloc] initWithItem:<span class="keyword">self</span><span class="variable">.image</span></div><div class="line">                                                    offsetFromCenter:centerOffset</div><div class="line">                                                    attachedToAnchor:location];</div><div class="line"><span class="comment">// 3</span></div><div class="line"><span class="keyword">self</span><span class="variable">.redSquare</span><span class="variable">.center</span> = <span class="keyword">self</span><span class="variable">.attachmentBehavior</span><span class="variable">.anchorPoint</span>;</div><div class="line"><span class="keyword">self</span><span class="variable">.blueSquare</span><span class="variable">.center</span> = location;</div><div class="line"> </div><div class="line"><span class="comment">// 4</span></div><div class="line">[<span class="keyword">self</span><span class="variable">.animator</span> addBehavior:<span class="keyword">self</span><span class="variable">.attachmentBehavior</span>];</div></pre></td></tr></table></figure>

<p>我们来细看一下上述代码的作用：</p>
<ol>
<li>首先移除 animator 中所有已有的行为。</li>
<li>创建一个 <code>UIAttachmentBehavior</code>，将用户 tap image view 上的点连接到一个锚点 (anchor point) 上 (实际上这恰好是完全相同的点)。随后，对锚点的改变，会引发 image view 的移动。</li>
</ol>
<p>将锚点连接到一个 view 上，就像安装了一个无形的拉杆：将锚点连接到 view 中固定的位置上。</p>
<ol>
<li>更新红色正方形，表示出锚点，而蓝色正方形则表示连接到 image view 内部的点 (现在他们都是一样的)。</li>
<li>将这个行为添加到 animator 中，使其具有效果。</li>
</ol>
<p>接下来需要告诉锚点跟住你的手指。为此，将下面的代码添加到 <code>handleAttachmentGesture:</code>，位于 <code>fefault</code> (与手势变化一起改变)：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span><span class="variable">.attachmentBehavior</span> setAnchorPoint:[gesture locationInView:<span class="keyword">self</span><span class="variable">.view</span>]];</div><div class="line"><span class="keyword">self</span><span class="variable">.redSquare</span><span class="variable">.center</span> = <span class="keyword">self</span><span class="variable">.attachmentBehavior</span><span class="variable">.anchorPoint</span>;</div></pre></td></tr></table></figure>

<p>上面的代码将锚点和红色正方形设置位手指当前的位置。当手指移动时，手势识别会调用这个方法，以更新相应的锚点信息。另外，animator 也会自动的按照这个锚点对 view 进行更新。</p>
<p>编译并运行程序，现在可以拖拽 view 了：</p>
<p>当完成拖拽，要是能降 view 还原到之前的位置就更好了。为此，将下面的方法添加到文件中：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)resetDemo</div><div class="line">{</div><div class="line">    [<span class="keyword">self</span><span class="variable">.animator</span> removeAllBehaviors];</div><div class="line"> </div><div class="line">    [<span class="built_in">UIView</span> animateWithDuration:<span class="number">0.45</span> animations:^{</div><div class="line">        <span class="keyword">self</span><span class="variable">.image</span><span class="variable">.bounds</span> = <span class="keyword">self</span><span class="variable">.originalBounds</span>;</div><div class="line">        <span class="keyword">self</span><span class="variable">.image</span><span class="variable">.center</span> = <span class="keyword">self</span><span class="variable">.originalCenter</span>;</div><div class="line">        <span class="keyword">self</span><span class="variable">.image</span><span class="variable">.transform</span> = CGAffineTransformIdentity;</div><div class="line">    }];</div><div class="line">}</div></pre></td></tr></table></figure>

<p>然后在方法 <code>handleAttachmentGesture:</code> 中调用这个方法，具体位于 <code>UIGestureRecognizerStateEnded</code>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span> resetDemo];</div></pre></td></tr></table></figure>

<p>编译并运行程序，现在完成对图片的拖拽之后，该图片应该能够回到最开始的位置。</p>
<p><a name="UIPushBehavior"></a></p>
<h2 id="UIPushBehavior">UIPushBehavior</h2>
<p>接下来，我们要完成这样的效果：当停止拖拽时，将 view 从屏幕中移除。那么当手势释放时，需要给这个 view 赋予动量，让它能继续沿着轨迹前行。为此，需要使用 <code>UIPushBehavior</code>。</p>
<p>首先，定义两个常量，将其添加到文件头部：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">CGFloat</span> ThrowingThreshold = <span class="number">1000</span>;</div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">CGFloat</span> ThrowingVelocityPadding = <span class="number">35</span>;</div></pre></td></tr></table></figure>

<p>为了让 view 持续移动，其中 <code>ThrowingThreshold</code> 表示 view 必须移动 (相对于立即返回到原点) 多快才行。<code>ThrowingVelocityPadding</code> 是一个神奇的常量，它将对抛掷 view 的快慢产生影响 (这需要反复试验得出结果)。</p>
<p>最后，在 <code>handleAttachmentGesture:</code>中，用下面的代码替换 <code>UIGestureRecognizerStateEnded</code> case：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> UIGestureRecognizerStateEnded: {</div><div class="line">    [<span class="keyword">self</span><span class="variable">.animator</span> removeBehavior:<span class="keyword">self</span><span class="variable">.attachmentBehavior</span>];</div><div class="line"> </div><div class="line">    <span class="comment">//1</span></div><div class="line">    <span class="built_in">CGPoint</span> velocity = [gesture velocityInView:<span class="keyword">self</span><span class="variable">.view</span>];</div><div class="line">    <span class="built_in">CGFloat</span> magnitude = sqrtf((velocity<span class="variable">.x</span> * velocity<span class="variable">.x</span>) + (velocity<span class="variable">.y</span> * velocity<span class="variable">.y</span>));</div><div class="line"> </div><div class="line">    <span class="keyword">if</span> (magnitude &gt; ThrowingThreshold) {</div><div class="line">        <span class="comment">//2</span></div><div class="line">        UIPushBehavior *pushBehavior = [[UIPushBehavior alloc]</div><div class="line">                                        initWithItems:@[<span class="keyword">self</span><span class="variable">.image</span>]</div><div class="line">                                        mode:UIPushBehaviorModeInstantaneous];</div><div class="line">        pushBehavior<span class="variable">.pushDirection</span> = CGVectorMake((velocity<span class="variable">.x</span> / <span class="number">10</span>) , (velocity<span class="variable">.y</span> / <span class="number">10</span>));</div><div class="line">        pushBehavior<span class="variable">.magnitude</span> = magnitude / ThrowingVelocityPadding;</div><div class="line"> </div><div class="line">        <span class="keyword">self</span><span class="variable">.pushBehavior</span> = pushBehavior;</div><div class="line">        [<span class="keyword">self</span><span class="variable">.animator</span> addBehavior:<span class="keyword">self</span><span class="variable">.pushBehavior</span>];</div><div class="line"> </div><div class="line">        <span class="comment">//3</span></div><div class="line">        <span class="built_in">NSInteger</span> angle = arc4random_uniform(<span class="number">20</span>) - <span class="number">10</span>;</div><div class="line"> </div><div class="line">        <span class="keyword">self</span><span class="variable">.itemBehavior</span> = [[UIDynamicItemBehavior alloc] initWithItems:@[<span class="keyword">self</span><span class="variable">.image</span>]];</div><div class="line">        <span class="keyword">self</span><span class="variable">.itemBehavior</span><span class="variable">.friction</span> = <span class="number">0.2</span>;</div><div class="line">        <span class="keyword">self</span><span class="variable">.itemBehavior</span><span class="variable">.allowsRotation</span> = <span class="literal">YES</span>;</div><div class="line">        [<span class="keyword">self</span><span class="variable">.itemBehavior</span> addAngularVelocity:angle forItem:<span class="keyword">self</span><span class="variable">.image</span>];</div><div class="line">        [<span class="keyword">self</span><span class="variable">.animator</span> addBehavior:<span class="keyword">self</span><span class="variable">.itemBehavior</span>];</div><div class="line"> </div><div class="line">        <span class="comment">//4</span></div><div class="line">        [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(resetDemo) withObject:<span class="literal">nil</span> afterDelay:<span class="number">0.4</span>];</div><div class="line">    }</div><div class="line"> </div><div class="line">    <span class="keyword">else</span> {</div><div class="line">        [<span class="keyword">self</span> resetDemo];</div><div class="line">    }</div><div class="line"> </div><div class="line">    <span class="keyword">break</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>我们来看看代码都做了些什么：</p>
<ol>
<li>获得手势的拖拽速度。</li>
</ol>
<p>利用速度和勾股定理 (Pythagorean theorem)，计算出速度的幅度 - 也就是由 x 方向上的速度和 y 方向上的速度构成的三角形斜边。</p>
<p>要想理解背后的理论，请看 <a href="http://www.raywenderlich.com/57368/trigonometry-game-programming-sprite-kit-version-part-1" target="_blank" rel="external">Trigonometry for Game Programming tutorial。</a></p>
<ol>
<li>假设手势的幅度超过了最低阀值，那么就配置一个 push behavior。</li>
</ol>
<p>push behavior 可以是持续性的，或者瞬间的应用到某个对象中。这里，我们需要给 image 一个瞬间的 push 行为。</p>
<p>我们希望 image 的移动方向是由 x 和 y 轴上的速度转换为一个矢量决定的。最后，将 push 行为添加到 animator 上。</p>
<ol>
<li>在这里给 image 添加一些旋转效果，让图片飞离屏幕。这里有复杂的数学知识<a href="https://github.com/u10int/URBMediaFocusViewController/blob/master/URBMediaFocusViewController.m#L636-L686" target="_blank" rel="external">介绍</a>。</li>
</ol>
<p>其中的一些效果取决于发起手势操作的手指与边缘的距离。</p>
<p>在此处，设置不同的值，观察它们移动的效果，然后使用最好的那个值即可。</p>
<ol>
<li>指定时间间隔之后，以动画的形式将 imamge 还原到最初状态。</li>
</ol>
<p>编译并运行程序，现在你应该可以用令人愉快的方式将 view 抛出屏幕！</p>
<p><img src="/images/2014/09/08.gif" alt=""></p>
<p><a name="Where_To_Go_From_Here"></a></p>
<h2 id="何去何从？">何去何从？</h2>
<p>这里可以下载到本文的最<a href="http://cdn4.raywenderlich.com/wp-content/uploads/2014/07/DynamicTossFinal.zip" target="_blank" rel="external">终示例工程</a>。</p>
<p>恭喜你，你现在已经学会如何做一些有趣的 UIKit dynamic 动画了 - 让程序的界面效果非常甜蜜。</p>
<p>如果你想要学习更多关于 UIKit Dynamics 的知识，可以阅读 <a href="http://www.raywenderlich.com/store/ios-7-by-tutorials" target="_blank" rel="external">iOS 7 for Tutorials</a> 中两章 UIKit Dynamics 内容。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="/images/2014/09/01.png" alt=""></p>
]]>
    
    </summary>
    
      <category term="iOS探索" scheme="http://beyondvincent.com/categories/iOS%E6%8E%A2%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何用 Swift 语言构建一个自定控件]]></title>
    <link href="http://beyondvincent.com/2014/08/28/2014-08-27-How-To-Make-a-Custom-Control-in-Swift/"/>
    <id>http://beyondvincent.com/2014/08/28/2014-08-27-How-To-Make-a-Custom-Control-in-Swift/</id>
    <published>2014-08-28T04:15:00.000Z</published>
    <updated>2014-12-31T19:05:45.000Z</updated>
    <content type="html"><![CDATA[<p><img src="/images/2014/08/01.png" alt=""></p>
<a id="more"></a>

<p>本文译自：<a href="http://www.raywenderlich.com/76433/how-to-make-a-custom-control-swift" target="_blank" rel="external">How To Make a Custom Control in Swift</a></p>
<p>用户界面控件是所有应用程序重要的组成部分之一。它们以图形组件的方式呈现给用户，用户可以通过它们与应用程序进行交互。苹果提供了一套控件，例如 <code>UITextField</code>，<code>UIButton</code>，<code>UISwitch</code>。通过工具箱中的这些已有控件，我们可以创建各式各样的用户界面。</p>
<p>然而，有时候你希望界面做得稍微的与众不同，那么此时苹果提供的这些控件就无法满足你的需求。</p>
<p>自定义控件，除了是自己构建二外，与苹果提供的，没什么差别。也就是说，自定义控件不存在于 UIKit 框架。自定义控件跟苹果提供的标准控件一样，应该是通用，并且多功能的。你也会发现，互联网上有一些积极的开发者乐意分享他们自定义的控件。</p>
<p>本文中，你将实现一个自己的 RangeSlider 自定义控件。这个控件是一个两端都可以滑动的，也就是说，你可以通过该控件获得最小值和最大值。你将会接触到这样一些概念：对现有控件的扩展，设计和实现自定义控件的 API，甚至还能学到如何分享你的自定义控件到开发社区中。</p>
<p>注意：本文截稿时，我们还不会贴出关于 iOS 8 beta 版本的截图。所有文中涉及到的截图都是在iOS 8之前的版本中得到的，不过结果非常类似。</p>
<p>目录：</p>
<ul>
<li><a href="#Getting_Started">开始</a></li>
<li><a href="#Images_vs._CoreGraphics">Images vs. CoreGraphics</a></li>
<li><a href="#Adding_Default_Control_Properties">添加默认的控件属性</a></li>
<li><a href="#Adding_Interactive_Logic">添加交互逻辑</a></li>
<li><a href="#Adding_Touch_Handlers">添加触摸处理</a></li>
<li><a href="#Change_Notifications">值改变的通知</a></li>
<li><a href="#Modifying_Your_Control_With_Core_Graphics">结合 Core Graphics 对控件进行修改</a></li>
<li><a href="#Handling_Changes_to_Control_Properties">处理控件属性的改变</a></li>
<li><a href="#Where_To_Go_From_Here">何去何从？</a></li>
</ul>
<hr>
<p><a name="Getting_Started"></a></p>
<h2 id="开始">开始</h2>
<p>假设你在开发一个应用程序，该程序提供搜索商品价格列表。通过这个假象的应用程序允许用户对搜索结果进行过滤，以获得一定价格范围的商品。你可能会提供这样一个用户界面：两个 <code>UISlider</code> 控件，一个用于设置最低价格，另外一个设置最高价格。然而，这样的设计，不能够让用户很好的感知价格的范围。要是能够提供一个 slider，两端可以分别设置用于搜索的最高和最低的价格范围，就更好了。</p>
<p>你可以通过创建一个 <code>UIView</code> 的子类，然后为可视的价格范围定做一个 view。这对于应用程序内部来说，是 ok的，但是要想移植到别的程序中，就需要花更多的精力了。</p>
<p>最好的办法是将构建一个新的尽可能通用的 UI 控件，这样就能在任意的合适场合中重用。这也是自定义控件的本质。</p>
<p>启动 Xcode，<code>File/New/Project</code>，选中 <code>iOS/Application/Single View Application</code> 模板，然后点击 <code>Next</code>。在接下来的界面中，输入 <code>CustomSliderExample</code> 当做工程名，然后是 <code>Organization Name</code> 和 <code>Organization Identifier</code>，然后，一定要确保选中 <code>Swift</code> 语言，<code>iPhone</code> 选中，<code>Use Core Data</code> 不要选。</p>
<p>最后，选择一个保存工程的地方并单击 <code>Create</code>。</p>
<p>首先，我们需要做出决定的就是创建自定义控件需要继承自哪个类，或者对哪个类进行扩展。</p>
<p>位了使自定义控件能够在应用程序中使用，你的类必须是 <code>UIView</code> 的一个子类。</p>
<p>如果你注意观察苹果的 <code>UIKit</code> 参考，会发现框架中的许多控件，例如 <code>UILabel</code> 和 <code>UIWebView</code> 都是直接继承自 <code>UIView</code> 的。然而，也有极少数，例如 <code>UIButton</code> 和 <code>UISwitch</code> 是继承自 <code>UIControl</code> 的，如下继承图所示：</p>
<p><img src="/images/2014/08/02.png" alt=""></p>
<p>注意：iOS 中 UI 组件的完整类继承图，请看 <a href="http://developer.apple.com/library/ios/#documentation/uikit/reference/UIKit_Framework/Introduction/Introduction.html" target="_blank" rel="external">UIKit Framework 参考</a>。</p>
<p><code>UIControl</code> 实现了 <code>target-action 模式</code>，这是一种将变化通知订阅者的机制。<code>UIControl</code> 同样还有一些与控件状态相关的属性。在本文中的自定义空间中，将使用到 target-action 模式，所以从 <code>UIControl</code> 开始继承使用将是一个非常好的切入点。</p>
<p>在 Project Navigator 中右键单击 <code>CustomSliderExample</code>，选择 <code>New File…</code>，然后选择 <code>iOS/Source/Cocoa Touch Class</code> 模板，并单击 <code>Next</code>。将类命名位 <code>RangeSlider</code>，在 <code>Subclass of</code> 字段中输入 <code>UIControl</code>，并确保语言是 <code>Swift</code>。然后单击 <code>Next</code>，并在默认存储位置中 <code>Create</code> 出新的类。</p>
<p>虽然编码非常让人愉悦，不过你可能也希望尽快看到自定义控件在屏幕中熏染出来的模样！在写自定义控件相关的任何代码之前，你应该先把这个控件添加到 view controller中，这样就可以实时观察控件的演进程度。</p>
<p>打开 <code>ViewController.swift</code>，用下面的内容替换之：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="type">UIKit</span></div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>{</div><div class="line">    <span class="keyword">let</span> rangeSlider = <span class="type">RangeSlider</span>(frame: <span class="type">CGRectZero</span>)</div><div class="line"> </div><div class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span></span> viewDidLoad() {</div><div class="line">        <span class="keyword">super</span>.viewDidLoad()</div><div class="line"> </div><div class="line">        rangeSlider.backgroundColor = <span class="type">UIColor</span>.redColor()</div><div class="line">        view.addSubview(rangeSlider)</div><div class="line">    }</div><div class="line"> </div><div class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span></span> viewDidLayoutSubviews() {</div><div class="line">        <span class="keyword">let</span> margin: <span class="type">CGFloat</span> = <span class="number">20.0</span></div><div class="line">        <span class="keyword">let</span> width = view.bounds.width - <span class="number">2.0</span> * margin</div><div class="line">        rangeSlider.frame = <span class="type">CGRect</span>(x: margin, y: margin + topLayoutGuide.length,</div><div class="line">            width: width, height: <span class="number">31.0</span>)</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面的代码根据指定的 frame 实例化了一个全新的控件，然后将其添加到 view 中。为了在应用程序背景中凸显出控件，我们将控件的背景色被设置位了红色。如果不把控件的背景色设置为红色，那么控件中什么都没有，可能会想，控件去哪里了！:]</p>
<p>编译并运行程序，将看到如下类似界面：</p>
<p><img src="/images/2014/08/03.png" alt=""></p>
<p>在开始给控件添加可视元素之前，应该先定义几个属性，用以在控件中记录下各种信息。这也是开始应用程序编程接口 (API) 的开始。</p>
<p>注意：控件中定义的方法和属性是你决定用来暴露给别的开发者使用的。稍后你将看到 API 设计相关的内容，现在只需要紧跟就行！</p>
<p><a name="Adding_Default_Control_Properties"></a></p>
<h2 id="添加默认的控件属性">添加默认的控件属性</h2>
<p>打开 <code>RangeSlider.swift</code>，用下面的代码替换之：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="type">UIKit</span></div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RangeSlider</span>: <span class="title">UIControl</span> </span>{</div><div class="line">    <span class="keyword">var</span> minimumValue = <span class="number">0.0</span></div><div class="line">    <span class="keyword">var</span> maximumValue = <span class="number">1.0</span></div><div class="line">    <span class="keyword">var</span> lowerValue = <span class="number">0.2</span></div><div class="line">    <span class="keyword">var</span> upperValue = <span class="number">0.8</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面定义的四个属性用来描述控件的状态，提供最大值和最小值，以及有用户设置的 upper 和 lower 两个值。</p>
<p>好的控件设计，应该提供一些默认的属性值，否则将你的控件绘制到屏幕中时，看起来会有点奇怪。</p>
<p>现在是时候开始做控件的交互元素了，我们分别用两个 thumbs 表示高和低两个值，并且让这两个 thumbs 能够滑动。</p>
<p><a name="Images_vs._CoreGraphics"></a></p>
<h2 id="Images_vs-_CoreGraphics">Images vs. CoreGraphics</h2>
<p>在屏幕中渲染控件有两种方法：</p>
<p>1、<code>Images</code> - 为控件构建不同的图片，这些图片代表控件的各种元素。<br>2、<code>Core Graphics</code> - 利用 layers 和 Core Graphics 组合起来熏染控件。</p>
<p>这两种方法都有利有弊，下面来看看：</p>
<p><code>Images</code> - 利用图片来构建控件是最简单的一种方法 - 只要你知道如何绘制图片！:] 如果你想要让开发者能够修改控件的外观，那么你应该将这些图片以 UIImage 属性的方式暴露出去。</p>
<p>通过图片的方式来构建的控件，给使用控件的人提供了非常大的灵活度。开发者可以改变每一个像素，以及控件的详细外观，不过这需要非常熟练的图形设计技能 - 并且通过代码非常难以对控件做出修改。</p>
<p><code>Core Graphics</code> - 利用 Core Graphics 构建控件意味着你必须自己编写渲染控件的代码，这就需要付出更多的代价。不过，这种方法可以创建更加灵活的 API。</p>
<p>使用 Core Graphics，可以把控件的所有特征都参数化，例如颜色、边框厚度和弧度 - 几乎每一个可视元素都通过绘制完成！这种方法运行开发者对控件做出任意调整，以适配相应的需求。</p>
<p>本文中，你将学到第二种技术 - 利用 Core Graphics 来熏染控件。</p>
<p>主要：有趣的时，苹果建议在他们提供的控件中使用图片。这可能是苹果知道每个控件的大小，他们不希望程序中出现太多的定制。也就是说，他们希望所有的应用程序，都具有相似的外观和体验。</p>
<p>打开 <code>RangeSlider.swift</code> 将下面的 import 添加到文件的顶部，也就是 <code>import UIKit</code> 下面：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="type">QuartzCore</span></div></pre></td></tr></table></figure>

<p>将下面的属性添加到 <code>RangeSlider</code> 中，也就是我们刚刚定义的那行代码下面：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> trackLayer = <span class="type">CALayer</span>()</div><div class="line"><span class="keyword">let</span> lowerThumbLayer = <span class="type">CALayer</span>()</div><div class="line"><span class="keyword">let</span> upperThumbLayer = <span class="type">CALayer</span>()</div><div class="line"> </div><div class="line"><span class="keyword">var</span> thumbWidth: <span class="type">CGFloat</span> {</div><div class="line">    <span class="keyword">return</span> <span class="type">CGFloat</span>(bounds.height)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里有 3 个 layer - <code>trackLayer</code>, <code>lowerThumbLayer</code>, 和 <code>upperThumbLayer</code> - 用来熏染滑块控件的不同组件。<code>thumbWidth</code> 用来布局使用。</p>
<p>接下来就是控件默认的一些图形属性。</p>
<p>在 <code>RangeSlider</code> 类中，添加一个 初始化方法，以及一个 helper 方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="keyword">init</span>(frame: <span class="type">CGRect</span>) {</div><div class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)</div><div class="line"> </div><div class="line">    trackLayer.backgroundColor = <span class="type">UIColor</span>.blueColor().<span class="type">CGColor</span></div><div class="line">    layer.addSublayer(trackLayer)</div><div class="line"> </div><div class="line">    lowerThumbLayer.backgroundColor = <span class="type">UIColor</span>.greenColor().<span class="type">CGColor</span></div><div class="line">    layer.addSublayer(lowerThumbLayer)</div><div class="line"> </div><div class="line">    upperThumbLayer.backgroundColor = <span class="type">UIColor</span>.greenColor().<span class="type">CGColor</span></div><div class="line">    layer.addSublayer(upperThumbLayer)</div><div class="line"> </div><div class="line">    updateLayerFrames()</div><div class="line">}</div><div class="line"> </div><div class="line">required <span class="keyword">init</span>(coder: <span class="type">NSCoder</span>) {</div><div class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>(coder: coder)</div><div class="line">}</div><div class="line"> </div><div class="line"><span class="func"><span class="keyword">func</span></span> updateLayerFrames() {</div><div class="line">    trackLayer.frame = bounds.rectByInsetting(dx: <span class="number">0.0</span>, dy: bounds.height / <span class="number">3</span>)</div><div class="line">    trackLayer.setNeedsDisplay()</div><div class="line"> </div><div class="line">    <span class="keyword">let</span> lowerThumbCenter = <span class="type">CGFloat</span>(positionForValue(lowerValue))</div><div class="line"> </div><div class="line">    lowerThumbLayer.frame = <span class="type">CGRect</span>(x: lowerThumbCenter - thumbWidth / <span class="number">2.0</span>, y: <span class="number">0.0</span>,</div><div class="line">      width: thumbWidth, height: thumbWidth)</div><div class="line">    lowerThumbLayer.setNeedsDisplay()</div><div class="line"> </div><div class="line">    <span class="keyword">let</span> upperThumbCenter = <span class="type">CGFloat</span>(positionForValue(upperValue))</div><div class="line">    upperThumbLayer.frame = <span class="type">CGRect</span>(x: upperThumbCenter - thumbWidth / <span class="number">2.0</span>, y: <span class="number">0.0</span>,</div><div class="line">        width: thumbWidth, height: thumbWidth)</div><div class="line">    upperThumbLayer.setNeedsDisplay()</div><div class="line">}</div><div class="line"> </div><div class="line"><span class="func"><span class="keyword">func</span></span> positionForValue(value: <span class="type">Double</span>) -&gt; <span class="type">Double</span> {</div><div class="line">    <span class="keyword">let</span> widthDouble = <span class="type">Double</span>(thumbWidth)</div><div class="line">    <span class="keyword">return</span> <span class="type">Double</span>(bounds.width - thumbWidth) * (value - minimumValue) /</div><div class="line">        (maximumValue - minimumValue) + <span class="type">Double</span>(thumbWidth / <span class="number">2.0</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>初始化方法简单的创建了 3 个 layer，并将它们以 children 的身份添加到控件的 root layer 中，然后通过 <code>updateLayerFrames</code> 对这些 layer 的位置进行更新定位! :]</p>
<p>最后，<code>positionForValue</code> 方法利用一个简单的比例，对控件的最小和最大值的范围做了一个缩放，将值映射到屏幕中确定的一个位置。</p>
<p>接下来，override一下 <code>frame</code>，通过将下面的代码添加到 <code>RangeSlider.swift</code> 中，实现对属性的观察：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="keyword">var</span> frame: <span class="type">CGRect</span> {</div><div class="line">    <span class="keyword">didSet</span> {</div><div class="line">        updateLayerFrames()</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>当 frame 发生变化时，属性观察者会更新 layer frame。这一步是必须的，因为当控件初始化时，传入的 frame 并不是最终的 frame，就像 <code>ViewController.swift</code> 中的。</p>
<p>编译并运行程序，可以看到滑块初具形状！看起来，如下图所示：</p>
<p><img src="/images/2014/08/04.png" alt=""></p>
<p>还记得吗，红色是整个控件的背景色。蓝色是滑块的轨迹，绿色 thumb 是两个代表两端的值。</p>
<p>现在控件看起来有形状了，不过几乎所有的控件都提供了相关方法，让用户与之交互。</p>
<p>针对本文中的控件，用户必须能够通过拖拽 2 个 thumb 来设置控件的范围。你将处理这些交互，并通过控件更新 UI 和暴露的属性。</p>
<p><a name="Adding_Interactive_Logic"></a></p>
<h2 id="添加交互逻辑">添加交互逻辑</h2>
<p>本文的交互逻辑需要存储那个 thumb 被拖拽了，并将效果反应到 UI 中。控件的 layer 是放置该逻辑的最佳位置。</p>
<p>跟之前一样，在 Xcode 中创建一个新的 <code>Cocoa Touch Class</code>，命名为 <code>RangeSliderThumbLayer</code>，继承自 <code>CALayer</code>。</p>
<p>用下面的代码替换掉 <code>RangeSliderThumbLayer.swift</code> 文件中的内容：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="type">UIKit</span></div><div class="line"><span class="keyword">import</span> <span class="type">QuartzCore</span></div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RangeSliderThumbLayer</span>: <span class="title">CALayer</span> </span>{</div><div class="line">    <span class="keyword">var</span> highlighted = <span class="built_in">false</span></div><div class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> rangeSlider: <span class="type">RangeSlider</span>?</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面的代码中简单的添加了两个属性：一个表示这个 thumb 是否 高亮 (highlighted)，另外一个引用回父 range slider。由于 RangeSlider 有两个 thumb layer，所以将这里的引用设置位 weak，避免循环引用。</p>
<p>打开 <code>RangeSlider.swift</code>，修改一下 <code>lowerThumbLayer</code> 和 <code>upperThumbLayer</code> 两个属性的类型，用下面的代码替换掉它们的定义：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> lowerThumbLayer = <span class="type">RangeSliderThumbLayer</span>()</div><div class="line"><span class="keyword">let</span> upperThumbLayer = <span class="type">RangeSliderThumbLayer</span>()</div></pre></td></tr></table></figure>

<p>还是在 <code>RangeSlider.swift</code> 中，找到 <code>init</code>，将下面的代码添加进去：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lowerThumbLayer.rangeSlider = <span class="keyword">self</span></div><div class="line">upperThumbLayer.rangeSlider = <span class="keyword">self</span></div></pre></td></tr></table></figure>

<p>上面的代码简单的将 layer 的 <code>rangeSlider</code> 属性设置为 <code>self</code>。</p>
<p>编译并运行程序，界面看起来没有什么变化。</p>
<p>现在你已经有了 slider 的thumb layer - RangeSliderThumbLayer，然后需要给控件添加拖拽 thumb 的功能。</p>
<p><a name="Adding_Touch_Handlers"></a></p>
<h2 id="添加触摸处理">添加触摸处理</h2>
<p>打开 <code>RangeSlider.swift</code>，将下面这个属性添加进去：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> previousLocation = <span class="type">CGPoint</span>()</div></pre></td></tr></table></figure>

<p>这个属性用来跟踪记录用户的触摸位置。</p>
<p>那么你该如何来跟踪控件的各种触摸和 release 时间呢？</p>
<p><code>UIControl</code> 提供了一些方法来跟踪触摸。<code>UIControl</code> 的子类可以 override 这些方法，以实现自己的交互逻辑。</p>
<p>在自定义控件中，我们将 override 3 个 <code>UIControl</code> 关键的方法：<code>beginTrackingWithTouch</code>, <code>continueTrackingWithTouch</code> 和 <code>endTrackingWithTouch</code>。</p>
<p>将下面的方法添加到 <code>RangeSlider.swift</code> 中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span></span> beginTrackingWithTouch(touch: <span class="type">UITouch</span>!, withEvent event: <span class="type">UIEvent</span>!) -&gt; <span class="type">Bool</span> {</div><div class="line">    previousLocation = touch.locationInView(<span class="keyword">self</span>)</div><div class="line"> </div><div class="line">    <span class="comment">// Hit test the thumb layers</span></div><div class="line">    <span class="keyword">if</span> lowerThumbLayer.frame.<span class="built_in">contains</span>(previousLocation) {</div><div class="line">        lowerThumbLayer.highlighted = <span class="built_in">true</span></div><div class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> upperThumbLayer.frame.<span class="built_in">contains</span>(previousLocation) {</div><div class="line">        upperThumbLayer.highlighted = <span class="built_in">true</span></div><div class="line">    }</div><div class="line"> </div><div class="line">    <span class="keyword">return</span> lowerThumbLayer.highlighted || upperThumbLayer.highlighted</div><div class="line">}</div></pre></td></tr></table></figure>

<p>当首次触摸控件时，会调用上面的方法。</p>
<p>代码中，首先将触摸事件的坐标转换到控件的坐标空间。然后检查每个 thumb，是否触摸位置在其上面。方法中返回的值将决定 UIControl 是否继续跟踪触摸事件。</p>
<p>如果任意一个 thumb 被 highlighted 了，就继续跟踪触摸事件。</p>
<p>现在，有了初始的触摸事件，我们需要处理用户在屏幕上移动的事件了。</p>
<p>将下面的方法添加到 <code>RangeSlider.swift</code> 中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="func"><span class="keyword">func</span></span> boundValue(value: <span class="type">Double</span>, toLowerValue lowerValue: <span class="type">Double</span>, upperValue: <span class="type">Double</span>) -&gt; <span class="type">Double</span> {</div><div class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(<span class="built_in">max</span>(value, lowerValue), upperValue)</div><div class="line">}</div><div class="line"> </div><div class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span></span> continueTrackingWithTouch(touch: <span class="type">UITouch</span>!, withEvent event: <span class="type">UIEvent</span>!) -&gt; <span class="type">Bool</span> {</div><div class="line">    <span class="keyword">let</span> location = touch.locationInView(<span class="keyword">self</span>)</div><div class="line"> </div><div class="line">    <span class="comment">// 1. Determine by how much the user has dragged</span></div><div class="line">    <span class="keyword">let</span> deltaLocation = <span class="type">Double</span>(location.x - previousLocation.x)</div><div class="line">	<span class="keyword">let</span> deltaValue = (maximumValue - minimumValue) * deltaLocation / <span class="type">Double</span>(bounds.width - bounds.height)</div><div class="line"> </div><div class="line">    previousLocation = location</div><div class="line"> </div><div class="line">    <span class="comment">// 2. Update the values</span></div><div class="line">    <span class="keyword">if</span> lowerThumbLayer.highlighted {</div><div class="line">        lowerValue += deltaValue</div><div class="line">        lowerValue = boundValue(lowerValue, toLowerValue: minimumValue, upperValue: upperValue)</div><div class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> upperThumbLayer.highlighted {</div><div class="line">        upperValue += deltaValue</div><div class="line">        upperValue = boundValue(upperValue, toLowerValue: lowerValue, upperValue: maximumValue)</div><div class="line">    }</div><div class="line"> </div><div class="line">    <span class="comment">// 3. Update the UI</span></div><div class="line">    <span class="type">CATransaction</span>.begin()</div><div class="line">    <span class="type">CATransaction</span>.setDisableActions(<span class="built_in">true</span>)</div><div class="line"> </div><div class="line">    updateLayerFrames()</div><div class="line"> </div><div class="line">    <span class="type">CATransaction</span>.commit()</div><div class="line"> </div><div class="line">    <span class="keyword">return</span> <span class="built_in">true</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>boundValue</code> 会将传入的值控制在某个确定的范围。通过这个方法比嵌套调用 <code>min/max</code> 更容易理解。</p>
<p>下面我们根据注释，来分析一下 <code>continueTrackingWithTouch</code> 方法都做了些什么：</p>
<ol>
<li>首先计算出位置增量，这个值决定着用户手指移动的数值。然后根据控件的最大值和最小值，对这个增量做转换。</li>
<li>根据用户滑动滑块的距离，修正一下 upper 或 lower 值。</li>
<li>设置 <code>CATransaction</code> 中的 <code>disabledActions</code>。这样可以确保每个 layer 的frame 立即得到更新，并且不会有动画效果。最后，调用 <code>updateLayerFrames</code> 方法将 thumb 移动到正确的位置。</li>
</ol>
<p>至此，已经编写了移动滑块的代码 - 不过我们还要处理触摸和拖拽事件的结束。</p>
<p>将下面方法添加到 <code>RangeSlider.swift</code> 中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span></span> endTrackingWithTouch(touch: <span class="type">UITouch</span>!, withEvent event: <span class="type">UIEvent</span>!) {</div><div class="line">    lowerThumbLayer.highlighted = <span class="built_in">false</span></div><div class="line">    upperThumbLayer.highlighted = <span class="built_in">false</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面的代码简单的将两个 thumb 还原位 non-highlighted 状态。</p>
<p>编译并运行程序，尝试移动滑块！现在你应该可以移动 thumb 了。</p>
<p><img src="/images/2014/08/05.png" alt=""></p>
<p>你可能注意到当在移动滑块时，可以在控件之外的范围对其拖拽，然后手指回到控件内，也不会丢失跟踪。其实这在小屏幕的设备上，是非常重要的一个功能。</p>
<p><a name="Change_Notifications"></a></p>
<h2 id="值改变的通知">值改变的通知</h2>
<p>现在你已经有一个可以交互的控件了 - 用户可以对其进行操作，以设置范围的大小值。但是如何才能把这些值的改变通知调用者：控件有新的值了呢？</p>
<p>这里有多种模式可以实现值改变的通知： <code>NSNotification</code>，<code>Key-Value-Observing</code> (KVO)， <code>delegate</code> 模式，<code>target-action</code> 模式等。有许多选择！</p>
<p>面对这么多的通知方式，那么我们该怎么选择呢？</p>
<p>如果你研究过 <code>UIKit</code> 控件，会发现它们并没有使用 <code>NSNotification</code>，也不鼓励使用 KVO。所以为了保持与 UIKit 的一致性，我们可以先排除这两种方法。另外的两种模式：delegate 和 target-action 被广泛用于 UIKit 中。</p>
<p><code>Delegate 模式</code> - delegate 模式需要提供一个 protocol，里面有一些用于通知的方法。控件中有一个属性，一般命名位 delegate，它可以是任意实现该协议的类。经典的一个示例就是 <code>UITableView</code> 提供了 <code>UITableViewDelegate</code> protocol。注意，控件只接受单个 delegate 实例。一个 delegate 方法可以使用任意的参数，所以可以给这样的方法传递尽可能多的信息。</p>
<p><code>Target-action 模式</code> - <code>UIControl</code> 基类已经提供了 target-action 模式。当控件状态发生了改变，target 会获得相应 action 的通知，该 action 是在 <code>UIControlEvents</code> 枚举值做定义的。我们可以给控件的 action 提供多个 target，另外还可以创建自定义事件 (查阅 <code>UIControlEventApplicationReserved</code>)，自定义事件的数量不得超过 4 个。控件 action 针对某个事件，无法传送任意的信息，所以当事件触发时，不能用它来传递额外的信息。</p>
<p>这两种模式关键不同点如下：</p>
<ul>
<li>多播 (Multicast) - target-action 模式可以对改变事件进行多播通知，而 delegate 模式只能绑定到单个 delegate 实例上。</li>
<li>灵活 (Flexibility) - 在 delegate 模式中，你可以定义自己的 protocol，这就意味着你可以控制信息的传递量。而 target-action 是无法传递额外信息的，客户端只能在收到事件后，自行查询信息。</li>
</ul>
<p>我们的 slider 控件不会有大量的状态变化，也不需要提供大量的通知。唯一真正改变的就是控件的 upper 和 lower 值。</p>
<p>基于这样的情况，使用 target-action 模式是最好的。这也是为什么在本文开头的时候告诉你为什么这个控件要继承自 <code>UIControl</code>。</p>
<p>slider 的值是在 <code>continueTrackingWithTouch:withEvent:</code> 方法中进行更新的，所以这个方法也是添加通知代码的地方。</p>
<p>打开 <code>RangeSlider.swift</code>，定位到 <code>continueTrackingWithTouch</code> 方法，然后将下面的代码添加到 <code>return true</code> 语句前面：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sendActionsForControlEvents(.<span class="type">ValueChanged</span>)</div></pre></td></tr></table></figure>

<p>上面的这行代码就能将值改变事件通知给任意的订阅者 target。</p>
<p>现在我们应该对这个事件进行订阅，并当事件来了以后，作出相应的处理。</p>
<p>打开 <code>ViewController.swift</code>，将下面这行代码添加到 <code>viewDidLoad</code> 尾部：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rangeSlider.addTarget(<span class="keyword">self</span>, action: <span class="string">"rangeSliderValueChanged:"</span>, forControlEvents: .<span class="type">ValueChanged</span>)</div></pre></td></tr></table></figure>

<p>通过上面的代码，每次 slider 发送 <code>UIControlEventValueChanged</code> action 时，都会调用 <code>rangeSliderValueChanged</code> 方法。</p>
<p>将下面的代码添加到 <code>ViewController.swift</code> 中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="func"><span class="keyword">func</span></span> rangeSliderValueChanged(rangeSlider: <span class="type">RangeSlider</span>) {</div><div class="line">    <span class="built_in">println</span>(<span class="string">"Range slider value changed: (<span class="subst">\(rangeSlider.lowerValue)</span> <span class="subst">\(rangeSlider.upperValue)</span>)"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>当 slider 值发生变化是，上面这个方法简单的将 slider 的值打印出来。</p>
<p>编译并运行程序，并移动一下 slider，可以在控制台中看到控件的值，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="type">Range</span> slider value changed: (<span class="number">0.117670682730924</span> <span class="number">0.390361445783134</span>)</div><div class="line"><span class="type">Range</span> slider value changed: (<span class="number">0.117670682730924</span> <span class="number">0.38835341365462</span>)</div><div class="line"><span class="type">Range</span> slider value changed: (<span class="number">0.117670682730924</span> <span class="number">0.382329317269078</span>)</div><div class="line"><span class="type">Range</span> slider value changed: (<span class="number">0.117670682730924</span> <span class="number">0.380321285140564</span>)</div><div class="line"><span class="type">Range</span> slider value changed: (<span class="number">0.119678714859438</span> <span class="number">0.380321285140564</span>)</div><div class="line"><span class="type">Range</span> slider value changed: (<span class="number">0.121686746987952</span> <span class="number">0.380321285140564</span>)</div></pre></td></tr></table></figure>

<p>看到 控件五颜六色的，你可能不高心，它开起来就像水果沙拉一样！</p>
<p>现在是时候给控件换换面目了！</p>
<p><a name="Modifying_Your_Control_With_Core_Graphics"></a></p>
<h2 id="结合_Core_Graphics_对控件进行修改">结合 Core Graphics 对控件进行修改</h2>
<p>首先，首选更新一下slider thumb 移动的轨迹图形。</p>
<p>跟之前一样，给工程添加另外一个继承自 <code>CALayer</code> 的子类，命名为 <code>RangeSliderTrackLayer</code>。</p>
<p>打开刚刚添加的文件 <code>RangeSliderTrackLayer.swift</code>，然后用下面的内容替换之：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="type">UIKit</span></div><div class="line"><span class="keyword">import</span> <span class="type">QuartzCore</span></div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RangeSliderTrackLayer</span>: <span class="title">CALayer</span> </span>{</div><div class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> rangeSlider: <span class="type">RangeSlider</span>?</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面的代码添加了一个到 slider 控件的引用，跟之前 thumb layer 做的一样。</p>
<p>打开 <code>RangeSlider.swift</code> 文件，找到 <code>trackLayer</code> 属性，用刚刚创建的这个类对其实例化，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> trackLayer = <span class="type">RangeSliderTrackLayer</span>()</div></pre></td></tr></table></figure>

<p>接下来，找到 <code>init</code> 并用下面的代码替换之：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">init</span>(frame: <span class="type">CGRect</span>) {</div><div class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)</div><div class="line"> </div><div class="line">    trackLayer.rangeSlider = <span class="keyword">self</span></div><div class="line">    trackLayer.contentsScale = <span class="type">UIScreen</span>.mainScreen().scale</div><div class="line">    layer.addSublayer(trackLayer)</div><div class="line"> </div><div class="line">    lowerThumbLayer.rangeSlider = <span class="keyword">self</span></div><div class="line">    lowerThumbLayer.contentsScale = <span class="type">UIScreen</span>.mainScreen().scale</div><div class="line">    layer.addSublayer(lowerThumbLayer)</div><div class="line"> </div><div class="line">    upperThumbLayer.rangeSlider = <span class="keyword">self</span></div><div class="line">    upperThumbLayer.contentsScale = <span class="type">UIScreen</span>.mainScreen().scale</div><div class="line">    layer.addSublayer(upperThumbLayer)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面的代码确保新的 track layer 引用到 range slider - 并没有再用那可怕的颜色了！然后将 <code>contentsScale</code> 因子设置位与设备的屏幕一样，这样可以确保所有的内容在 retina 显示屏中没有问题。</p>
<p>下面还有一个事情需要做，就是将 <code>viewDidLoad</code> 中的如下代码移除掉：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rangeSlider.backgroundColor = <span class="type">UIColor</span>.redColor()</div></pre></td></tr></table></figure>

<p>编译并运行程序，看到什么了呢？</p>
<p><img src="/images/2014/08/06.png" alt=""></p>
<p>什么东西都没有？这是正确的！</p>
<p>不要烦恼 - 我们只不过移除掉了在 layer 中花哨的测试颜色。控件依旧存在 - 只不过现在是白色的！</p>
<p>由于许多开发者希望能够通过编码对控件做各种配置，以使其外观能够效仿一些流行的程序，所以我们给 slider 添加一些属性，运行开发者对其外观做出一些定制。</p>
<p>打开 <code>RangeSlider.swift</code>，将下面的属性添加到已有属性下面：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> trackTintColor = <span class="type">UIColor</span>(white: <span class="number">0.9</span>, alpha: <span class="number">1.0</span>)</div><div class="line"><span class="keyword">var</span> trackHighlightTintColor = <span class="type">UIColor</span>(red: <span class="number">0.0</span>, green: <span class="number">0.45</span>, blue: <span class="number">0.94</span>, alpha: <span class="number">1.0</span>)</div><div class="line"><span class="keyword">var</span> thumbTintColor = <span class="type">UIColor</span>.whiteColor()</div><div class="line"> </div><div class="line"><span class="keyword">var</span> curvaceousness : <span class="type">CGFloat</span> = <span class="number">1.0</span></div></pre></td></tr></table></figure>

<p>这些颜色属性的目的非常容易理解，但是 <code>curvaceousness</code>？这个属性在这里有点趣味 - 稍后你将发现其用途！</p>
<p>接下来，打来 <code>RangeSliderTrackLayer.swift</code>。</p>
<p>这个 layer 用来渲染两个 thumb 滑动的轨迹。目前它继承自 <code>CALayer</code>，仅仅是绘制一个单一颜色。</p>
<p>为了绘制轨迹，需要实现方法 <code>drawInContext:</code>，并利用 Core Pgraphics APIs 来进行渲染。</p>
<p>注意：要想深入学习 Core Graphics，建议阅读 <a href="http://www.raywenderlich.com/2033/core-graphics-tutorial-for-ios-lines-rectangles-and-gradients" target="_blank" rel="external">Core Graphics 101 教程</a>。</p>
<p>将下面这个方法添加到 <code>RangeSliderTrackLayer</code> 中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span></span> drawInContext(ctx: <span class="type">CGContext</span>!) {</div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> slider = rangeSlider {</div><div class="line">        <span class="comment">// Clip</span></div><div class="line">        <span class="keyword">let</span> cornerRadius = bounds.height * slider.curvaceousness / <span class="number">2.0</span></div><div class="line">        <span class="keyword">let</span> path = <span class="type">UIBezierPath</span>(roundedRect: bounds, cornerRadius: cornerRadius)</div><div class="line">        <span class="type">CGContextAddPath</span>(ctx, path.<span class="type">CGPath</span>)</div><div class="line"> </div><div class="line">        <span class="comment">// Fill the track</span></div><div class="line">        <span class="type">CGContextSetFillColorWithColor</span>(ctx, slider.trackTintColor.<span class="type">CGColor</span>)</div><div class="line">        <span class="type">CGContextAddPath</span>(ctx, path.<span class="type">CGPath</span>)</div><div class="line">        <span class="type">CGContextFillPath</span>(ctx)</div><div class="line"> </div><div class="line">        <span class="comment">// Fill the highlighted range</span></div><div class="line">        <span class="type">CGContextSetFillColorWithColor</span>(ctx, slider.trackHighlightTintColor.<span class="type">CGColor</span>)</div><div class="line">        <span class="keyword">let</span> lowerValuePosition = <span class="type">CGFloat</span>(slider.positionForValue(slider.lowerValue))</div><div class="line">        <span class="keyword">let</span> upperValuePosition = <span class="type">CGFloat</span>(slider.positionForValue(slider.upperValue))</div><div class="line">        <span class="keyword">let</span> rect = <span class="type">CGRect</span>(x: lowerValuePosition, y: <span class="number">0.0</span>, width: upperValuePosition - lowerValuePosition, height: bounds.height)</div><div class="line">        <span class="type">CGContextFillRect</span>(ctx, rect)</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>一旦 track 形状确定，控件的背景色就会被填充，另外高亮范围也会被填充。</p>
<p>编译并运行程序，会看到新的 track layer 被完美的渲染出来！如下图所示：</p>
<p><img src="/images/2014/08/07.png" alt=""></p>
<p>给暴露出来的属性设置不同的值，观察一下它们是如何反应到控件渲染中的。</p>
<p>如果你对 <code>curvaceousness</code> 做什么的还存在疑惑，那么试着修改一下它看看！</p>
<p>接下来我们使用相同的方法来绘制 thumb layer。</p>
<p>打开 <code>RangeSliderThumbLayer.swift</code>，然后将下面的方法添加到属性声明的下方：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span></span> drawInContext(ctx: <span class="type">CGContext</span>!) {</div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> slider = rangeSlider {</div><div class="line">        <span class="keyword">let</span> thumbFrame = bounds.rectByInsetting(dx: <span class="number">2.0</span>, dy: <span class="number">2.0</span>)</div><div class="line">        <span class="keyword">let</span> cornerRadius = thumbFrame.height * slider.curvaceousness / <span class="number">2.0</span></div><div class="line">        <span class="keyword">let</span> thumbPath = <span class="type">UIBezierPath</span>(roundedRect: thumbFrame, cornerRadius: cornerRadius)</div><div class="line"> </div><div class="line">        <span class="comment">// Fill - with a subtle shadow</span></div><div class="line">        <span class="keyword">let</span> shadowColor = <span class="type">UIColor</span>.grayColor()</div><div class="line">        <span class="type">CGContextSetShadowWithColor</span>(ctx, <span class="type">CGSize</span>(width: <span class="number">0.0</span>, height: <span class="number">1.0</span>), <span class="number">1.0</span>, shadowColor.<span class="type">CGColor</span>)</div><div class="line">        <span class="type">CGContextSetFillColorWithColor</span>(ctx, slider.thumbTintColor.<span class="type">CGColor</span>)</div><div class="line">        <span class="type">CGContextAddPath</span>(ctx, thumbPath.<span class="type">CGPath</span>)</div><div class="line">        <span class="type">CGContextFillPath</span>(ctx)</div><div class="line"> </div><div class="line">        <span class="comment">// Outline</span></div><div class="line">        <span class="type">CGContextSetStrokeColorWithColor</span>(ctx, shadowColor.<span class="type">CGColor</span>)</div><div class="line">        <span class="type">CGContextSetLineWidth</span>(ctx, <span class="number">0.5</span>)</div><div class="line">        <span class="type">CGContextAddPath</span>(ctx, thumbPath.<span class="type">CGPath</span>)</div><div class="line">        <span class="type">CGContextStrokePath</span>(ctx)</div><div class="line"> </div><div class="line">        <span class="keyword">if</span> highlighted {</div><div class="line">            <span class="type">CGContextSetFillColorWithColor</span>(ctx, <span class="type">UIColor</span>(white: <span class="number">0.0</span>, alpha: <span class="number">0.1</span>).<span class="type">CGColor</span>)</div><div class="line">            <span class="type">CGContextAddPath</span>(ctx, thumbPath.<span class="type">CGPath</span>)</div><div class="line">            <span class="type">CGContextFillPath</span>(ctx)</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>一旦定义好了 thumb 的形状路径，就会将其形状填充好。注意绘制微弱的阴影看起来的效果就是 thumb 上方的轨迹。接下来是绘制边框。最后，如果 thumb 是高亮的 - 也就是被移动状态 - 那么就绘制微弱的灰色阴影效果。</p>
<p>在运行之前，还有最后一件事情要做。按照下面的代码对 <code>highlighted</code> 属性的定义做出修改：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> highlighted: <span class="type">Bool</span> = <span class="built_in">false</span> {</div><div class="line">    <span class="keyword">didSet</span> {</div><div class="line">        setNeedsDisplay()</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里，定义了一个属性观察者，这样当每次 highlighted 属性修改时，相应的 layer 都会得到重绘。这会使得触摸事件发生时，填充色发生轻微的变动。</p>
<p>再次编译并运行程序，这下看起来会非常的有形状，如下图所示：</p>
<p><img src="/images/2014/08/08.png" alt=""></p>
<p>不难发现，用 Core Graphics 来绘制控件是非常值得做的。使用 Core Graphics 可以做出比通过图片渲染方法更通用的控件。</p>
<p><a name="Handling_Changes_to_Control_Properties"></a></p>
<h2 id="处理控件属性的改变">处理控件属性的改变</h2>
<p>那么到现在，还有什么事情要做呢？控件现在看起来已经非常的华丽了，它的外观是通用的，并且也支持 target-action 通知。</p>
<p>貌似已经做完了？</p>
<p>思考一下，如果当控件熏染之后，如果通过代码对 slider 的属性做了修改，会发生什么？例如，你希望修改一下 slider 的默认值，或者修改一下 track highlight，表示出一个有效范围。</p>
<p>目前，还没有任何代码来观察属性的设置情况。我们需要将其添加到控件中。我们需要实现属性观察者，来更新控件的 frame 或者重绘控件。打开 <code>RangeSlider.swift</code>，按照下面的代码对属性的声明作出修改：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> minimumValue: <span class="type">Double</span> = <span class="number">0.0</span> {</div><div class="line">    <span class="keyword">didSet</span> {</div><div class="line">        updateLayerFrames()</div><div class="line">    }</div><div class="line">}</div><div class="line"> </div><div class="line"><span class="keyword">var</span> maximumValue: <span class="type">Double</span> = <span class="number">1.0</span> {</div><div class="line">    <span class="keyword">didSet</span> {</div><div class="line">        updateLayerFrames()</div><div class="line">    }</div><div class="line">}</div><div class="line"> </div><div class="line"><span class="keyword">var</span> lowerValue: <span class="type">Double</span> = <span class="number">0.2</span> {</div><div class="line">    <span class="keyword">didSet</span> {</div><div class="line">        updateLayerFrames()</div><div class="line">    }</div><div class="line">}</div><div class="line"> </div><div class="line"><span class="keyword">var</span> upperValue: <span class="type">Double</span> = <span class="number">0.8</span> {</div><div class="line">    <span class="keyword">didSet</span> {</div><div class="line">        updateLayerFrames()</div><div class="line">    }</div><div class="line">}</div><div class="line"> </div><div class="line"><span class="keyword">var</span> trackTintColor: <span class="type">UIColor</span> = <span class="type">UIColor</span>(white: <span class="number">0.9</span>, alpha: <span class="number">1.0</span>) {</div><div class="line">    <span class="keyword">didSet</span> {</div><div class="line">        trackLayer.setNeedsDisplay()</div><div class="line">    }</div><div class="line">}</div><div class="line"> </div><div class="line"><span class="keyword">var</span> trackHighlightTintColor: <span class="type">UIColor</span> = <span class="type">UIColor</span>(red: <span class="number">0.0</span>, green: <span class="number">0.45</span>, blue: <span class="number">0.94</span>, alpha: <span class="number">1.0</span>) {</div><div class="line">    <span class="keyword">didSet</span> {</div><div class="line">        trackLayer.setNeedsDisplay()</div><div class="line">    }</div><div class="line">}</div><div class="line"> </div><div class="line"><span class="keyword">var</span> thumbTintColor: <span class="type">UIColor</span> = <span class="type">UIColor</span>.whiteColor() {</div><div class="line">    <span class="keyword">didSet</span> {</div><div class="line">        lowerThumbLayer.setNeedsDisplay()</div><div class="line">        upperThumbLayer.setNeedsDisplay()</div><div class="line">    }</div><div class="line">}</div><div class="line"> </div><div class="line"><span class="keyword">var</span> curvaceousness: <span class="type">CGFloat</span> = <span class="number">1.0</span> {</div><div class="line">    <span class="keyword">didSet</span> {</div><div class="line">        trackLayer.setNeedsDisplay()</div><div class="line">        lowerThumbLayer.setNeedsDisplay()</div><div class="line">        upperThumbLayer.setNeedsDisplay()</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>一般情况，我们需要根据依赖的属性，调用 <code>setNeedsDisplay</code> 方法将对于的 layer 进行重新处理。<code>setLayerFrames</code> 方法会对控件的布局作出调整。</p>
<p>现在，找到 <code>updateLayerFrames</code>，然后将下面的代码添加到该方法的顶部：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="type">CATransaction</span>.begin()</div><div class="line"><span class="type">CATransaction</span>.setDisableActions(<span class="built_in">true</span>)</div></pre></td></tr></table></figure>

<p>并将下面的代码添加到方法的尾部：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="type">CATransaction</span>.commit()</div></pre></td></tr></table></figure>

<p>上面的代码将整个 frame 的更新封装到一个事物处理中，这样可以让界面重绘变得流畅。同样还明确的把 layer 中的动画禁用掉，跟之前一样，这样 layer frame 的更新会变得即时。</p>
<p>由于现在每当 upper 和 lower 值发生变动时， frame 会自动更新了，所以，找到 <code>continueTrackingWithTouch</code> 方法，并将下面的代码删除掉：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 3. Update the UI</span></div><div class="line"><span class="type">CATransaction</span>.begin()</div><div class="line"><span class="type">CATransaction</span>.setDisableActions(<span class="built_in">true</span>)</div><div class="line"> </div><div class="line">updateLayerFrames()</div><div class="line"> </div><div class="line"><span class="type">CATransaction</span>.commit()</div></pre></td></tr></table></figure>

<p>上面的这些代码就能够确保属性变化时，能够反应到 slider 控件中。</p>
<p>为了确保代码无误，我们需要写点测试 case 进行测试。</p>
<p>打开 <code>ViewController.swift</code>，并将下面代码添加到 <code>viewDidLoad:</code> 尾部：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> time = dispatch_time(<span class="type">DISPATCH_TIME_NOW</span>, <span class="type">Int64</span>(<span class="type">NSEC_PER_SEC</span>))</div><div class="line">dispatch_after(time, dispatch_get_main_queue()) {</div><div class="line">    <span class="keyword">self</span>.rangeSlider.trackHighlightTintColor = <span class="type">UIColor</span>.redColor()</div><div class="line">    <span class="keyword">self</span>.rangeSlider.curvaceousness = <span class="number">0.0</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面的代码会在暂停 1 秒钟之后，对控件的一些属性做出更新。其中将 track highlight 的颜色修改为红色，并修改了 slider 和 thumb 的形状。</p>
<p>编译并运行程序，一秒钟之后，你看到 slider 由：</p>
<p><img src="/images/2014/08/09.png" alt=""></p>
<p>变为：</p>
<p><img src="/images/2014/08/10.png" alt=""></p>
<p>很容易不是吗？</p>
<p>上面刚刚添加到 view controller 中的代码，演示了一个非常有趣，而又经常被忽略的内容 - 对开发的自定义控件做充分的测试。当你在开发一个自定义控件时，你需要负责对所有的属性和外观做出验证。这里有一个好的方法就是创建不同的按钮和滑块 (它们连接到控件的不同属性) 对控件做出测试。这样，你就可以实时修改控件的属性，并实时观察到它们的结果。</p>
<p><a name="Where_To_Go_From_Here"></a></p>
<h2 id="何去何从？">何去何从？</h2>
<p>现在我们的 range slider 控件已经完成开发，并可以在程序中使用了！你可以在<a href="http://cdn4.raywenderlich.com/wp-content/uploads/2014/08/CustomSliderExample-Swift.zip" target="_blank" rel="external">这里</a>下载到完整的工程。</p>
<p>不过，创建通用性自定义控件的一个关键好处就是你可以将其用于不同的工程 - 并且分享给别的开发者使用。</p>
<p>准备好了吗？</p>
<p>实际上还没有。在分享自定义控件之前，还有一些事情需要考虑：</p>
<p><code>文档</code> - 你可能认为代码写得非常的完美，具有自我陈述的能力，不在需要额外的文档了，不过别的开发者是不同意的。最佳实践就是提供 public API 的相关文档，至少要提供所有分享的 public 代码，也就是说对所有的public 类和属性进行文档化。</p>
<p>例如，文档中需要说明 <code>RangeSlider</code> 是什么的 - slider 是这样的一个东西：定义了 4 个属性，包括minimumValue, maximumValue, lowerValue, 和 upperValue - 它是做什么的 - 允许用户通过在界面中定义数值的范围。</p>
<p><code>鲁棒性</code> - 如果将 <code>upperValue</code> 设置为比 <code>maximumValue</code> 还要大，会发生什么？当然，你是肯定不会这样做的 - 这是愚蠢的一件事情，不是吗？但是你无法保证所有的人都不这么做！你需要确保控件的状态总是有效 - 尽管一些愚蠢的码农会尝试这样做。</p>
<p><code>API 设计</code> - 前面说的鲁棒性涉及到一个更广泛的主题 - API 设计。创建一个具有灵活性、直观性和鲁棒性的 API 有利于控件被广泛的使用和流行。</p>
<p>API 设计是很深的一个主题，超出了本文的介绍范围，如果你感兴趣，建议阅读 <a href="http://mattgemmell.com/2012/05/24/api-design/" target="_blank" rel="external">Matt Gemmel 关于 API 设计的 25 条规则</a>。</p>
<p>网络中有许多地方可以分享你的控件。下面是建议的一些地方：</p>
<ul>
<li><a href="https://github.com/" target="_blank" rel="external">GitHub</a> - GitHub 已经是分享开源项目首选的一个地方。在 GitHub 上有大量关于 iOS 的自定义控件。GitHub 的伟大之处在于它允许人们很容易的就能访问到你共享的代码，也能够很容易的通过 forking 你的共享的代码，与别的控件进行协作开发，另外还能很方便的对控件 faise issues。</li>
<li><a href="http://cocoapods.org/" target="_blank" rel="external">CocoaPods</a> - CocoaPods 是一个 iOS 和 OSX 工程的第三方库依赖管理工具， 允许开发者很容易的将你的控件添加到他们的工程中，所以你可以通过 CocoaPods 分享你的控件。</li>
<li><a href="http://www.cocoacontrols.com/" target="_blank" rel="external">Cocoa Controls</a> - 这个网站位商业和开源的控件提供一个目录。许多开源控件都会提供到 Cocoa Control 上面，然后 host 在 GitHub 中，这是促进你进行创作的伟大方式。</li>
</ul>
<p>希望通过本文的学习，你已经能愉悦的创建 slider 控件了，可能你还希望构建自己的自定义控件。如果你做了，可以在本文的评论中分享一下 - 我们非常想看到你的创作！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="/images/2014/08/01.png" alt=""></p>
]]>
    
    </summary>
    
      <category term="iOS探索" scheme="http://beyondvincent.com/categories/iOS%E6%8E%A2%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在企业内部分发 iOS 应用程序]]></title>
    <link href="http://beyondvincent.com/2014/07/30/2014-07-30-provision-ios-ipa-app-for-in-house-enterprise-distribution/"/>
    <id>http://beyondvincent.com/2014/07/30/2014-07-30-provision-ios-ipa-app-for-in-house-enterprise-distribution/</id>
    <published>2014-07-30T04:15:00.000Z</published>
    <updated>2014-12-31T19:05:45.000Z</updated>
    <content type="html"><![CDATA[<p><img src="/images/2014/07/01.png" alt=""></p>
<a id="more"></a>


<p>本文译自：<a href="http://johannesluderschmidt.de/provision-ios-ipa-app-for-in-house-enterprise-distribution/2993/" target="_blank" rel="external">Provision iOS IPA App for In-House Enterprise Distribution</a></p>
<p>在企业内部分发 iOS 应用程序非常复杂。经过努力，我成功实现了在企业内部的应用程序分发。我决定用此文来记录我的最佳实践方法，以供将来参考。</p>
<p>如果你希望通过 Safari 能在任意的 iOS 设备上安装应用程序 (不需要发布到 App Store，也不需要通过 iTunes，以及 <a href="http://www.apple.com/iphone/business/it/management.html" target="_blank" rel="external">MDM</a> - 通过 MDM 方法会用到本文<a href="#Create_the_IPA_file_and_the_manifest">创建的 IPA 和 manifest</a>，那么这篇文章可以帮助你。</p>
<p>在开始发布企业应用之前，需要具备以下条件：</p>
<ol>
<li>必须是 <a href="https://developer.apple.com/programs/ios/enterprise/" target="_blank" rel="external">iOS Developer Enterprise Program</a> 中的团队成员 (至少是一个 admin)。每年需要向苹果支付费用 299$。普通的 iOS Developer Program 无法进行企业应用发布。腻味苹果希望额外确保客户能够对你和你的公司信任，所以你需要申请企业计划。公司的 CEO 需要跟苹果签一个合同。</li>
<li>域名需要一个有效的 SSL 证书，该域名用来放置应用程序。没有有效的 SSL 证书，iOS 设备将无法从站点安装应用程序。这样的 SSL 证书也非常昂贵。</li>
</ol>
<hr>
<p>下面介绍一下我开发中的相关环境配置。我使用 Xcode 5.1，和 iOS 7.1。我还是一个 iOS Developer Program team 的 admin 成员。互联网上我发现许多过时的相关设置。如果在以后，你发现了错误，或者有更好的解决方案，请回复告诉我！</p>
<p>要想按照本文完成应用的企业分发，必须按照以下内容作为出发点：</p>
<ol>
<li>在 Xcode 中有一个用于企业级分发的工程。</li>
<li>在 iOS Developer Enterprise Program team 中为此工程创建一个 App ID。稍后将在 配置文件中使用到这个 ID。如果还没有准备好这些，<a href="https://developer.apple.com/account/ios/identifiers/bundle/bundleList.action" target="_blank" rel="external">先来这里创建一个恰当的 App ID</a>。此处不再详细介绍如何创建 App ID。</li>
</ol>
<p>在本文中，我们将创建下面这些内容：</p>
<ul>
<li><a href="#Create_the_distribution_certificate">创建发布证书 (distribution certificate)</a></li>
<li><a href="#Create_the_provisioning_profile">创建配置文件 (provisioning profile)</a></li>
<li><a href="#Create_the_IPA_file_and_the_manifest">创建 IPA 和 manifest</a></li>
</ul>
<hr>
<p><a name="Create_the_distribution_certificate"></a></p>
<h2 id="创建发布证书_(distribution_certificate)">创建发布证书 (distribution certificate)</h2>
<p>针对企业级发布，需要一个发布证书 (发布证书与开发证书不同)对代码进行签名。这个证书仅对创建发布的应用程序有用。不能在 Xcode 的开发中使用。</p>
<p>如何获得发布证书：在 <a href="https://developer.apple.com/devcenter/ios/index.action" target="_blank" rel="external">iOS Dev Center</a> 中，导航至 <a href="https://developer.apple.com/account/ios/certificate/certificateList.action" target="_blank" rel="external">Certificates 小节</a>。这里需要登录到企业开发中心！另外还需要一个至少是 admin 的角色成员 (点击查阅<a href="https://developer.apple.com/programs/roles/index_enterprise.php" target="_blank" rel="external">iOS 开发中心更多关于角色介绍</a>)。然后点击 <a href="https://developer.apple.com/account/ios/certificate/certificateList.action?type=distribution" target="_blank" rel="external">Production</a>，会看到如下内容 (敏感部位已经涂黑)</p>
<p><img src="/images/2014/07/02.png" alt=""></p>
<p>在上图中，列出了创建好的所有证书。如果已经创建了一个发布证书，可以重用。不过，重要的是创建证书时所用的证书签名请求文件。如果这个文件没有，那么在 Keychain 中的证书将不会有对应的私钥，也就不能用这个证书对代码做签名。如果你已经记不得是否创建过证书，可以先下载相关的证书，然后双击打开它，在 Keychain Access 应用程序中可以看到相关信息。如果在证书的左侧有一个小的箭头，那么说明在你们的 Mac 电脑中已经存储了此证书对应的私钥，也就可以用该证书对代码进行签名。通过单击箭头展开证书，看起来如下图所示：</p>
<p><img src="/images/2014/07/03.png" alt=""></p>
<p>如果没有箭头，说明还没有私钥。要么就是私钥存储在另外一台 Mac 电脑，那么可以将其传到当前 Mac 电脑中。要么就是你没有私钥，这种情况下，你是不能用这个证书来签名分发应用程序的。解决办法就是：在苹果开发网站中试试别的证书，或者创建一个新的证书：通过在 Mac 电脑中创建一个新的证书签名请求文件。</p>
<hr>
<p>如果还没有构建的话，通过点击右上角的 ➕ 按钮来创建发布证书，会看到如下界面 (希望截图与你看到的稍微有点不同)：</p>
<p><img src="/images/2014/07/04.png" alt=""></p>
<p>选中圆形按钮 <code>In-House and Ad Hoc</code>。不知道为何，当我为本文截图时，我无法点击这个按钮。可能是我已经创建了一个发布证书，所以这个按钮不可选。不管怎样，你应该可以选这个按钮的。</p>
<hr>
<p>在接下来的界面中，会看到这样：</p>
<p><img src="/images/2014/07/05.png" alt=""></p>
<p>这个界面告诉你如何创建一个 CSR 文件，该文件用于证书的创建。如果你不知道是否已经创建好了这样的一个文件，那么建议在 Spotlight 中输入 <code>certSigningRequest</code>，对电脑中的内容进行搜索。如果有这样一个文件，可以将其用来创建证书，要是没有的话，就手动创建一个。</p>
<hr>
<p>创建好 CSR 文件之后，点击 <code>Continue</code> 来到下一个界面：</p>
<p><img src="/images/2014/07/06.png" alt=""></p>
<p>选择 CSR 文件，然后点击 <code>Generate</code>。</p>
<hr>
<p>现在，证书已经创建好了：</p>
<p><img src="/images/2014/07/07.png" alt=""></p>
<p>将其下载到本地，然后双击安装到 Keychain中。</p>
<hr>
<p><a name="Create_the_provisioning_profile"></a></p>
<h2 id="创建配置文件_(provisioning_profile)">创建配置文件 (provisioning profile)</h2>
<p>要创建用于发布的配置文件，定位到 <a href="https://developer.apple.com/account/ios/profile/profileList.action?type=production" target="_blank" rel="external">Provisioning Profiles 的 Distribution 小节</a>。然后点击右上角的 ➕ 按钮。现在看到如下图所示界面：</p>
<p><img src="/images/2014/07/08.png" alt=""></p>
<p>选中 <code>In House</code>，然后单击 <code>Continue</code>。选择为程序创建的 App ID：</p>
<p><img src="/images/2014/07/09.png" alt=""></p>
<p>然后单击 <code>Continue</code>。现在选择正确的发布证书：</p>
<p><img src="/images/2014/07/10.png" alt=""></p>
<p>单击 <code>Continue</code>。最后，命名配置文件，然后单击 <code>Generate</code>。</p>
<hr>
<p>下载生成的配置文件，双击安装它：</p>
<p><img src="/images/2014/07/11.png" alt=""></p>
<hr>
<p><a name="Create_the_IPA_file_and_the_manifest"></a></p>
<h2 id="创建_IPA_和_manifest">创建 IPA 和 manifest</h2>
<p>打开 Xcode，开始创建 IPA 文件。单击左上角中的项目名称。在中间区域，选择 <code>targets</code> 中的项目名称。选择顶部的 <code>General</code>。在 <code>Team</code> 中，选择 iOS Developer Enterprise Program 团队的名称。(为了本文，我选择了私人账号中的团队，记得用企业团队替代！)：</p>
<p><img src="/images/2014/07/12.png" alt=""></p>
<p>在中间区域，选择 <code>Project</code> 中的工程名。单击顶部的 <code>Build Settings</code>。在 <code>Code Signing</code> 中选择发布证书：</p>
<p><img src="/images/2014/07/13.png" alt=""></p>
<p>回到 中间区域的 target 中。单击项目名称。单击顶部的 <code>Build Settings</code>。在 Debug, Any iOS SDK, Release 和 Any iOS SDK 中选择发布证书。在 provisioning，选择之前创建的配置文件：</p>
<p><img src="/images/2014/07/14.png" alt=""></p>
<hr>
<p>记住，上面这样的配置无法从 Xcode 将 应用程序运行至设备中。这些配置仅用于发布。(你可以点击 ▶ ，Xcode 将编译整个工程，并尝试将程序运行到设备或者模拟器中。但是之后会看到一个错误信息)。现在，点击菜单中的 <code>Product</code> -&gt; <code>Archive</code>。如果 <code>Archive</code> 不可用，那么需要在 run scheme 中选择一个真实的 iOS 设备。Run scheme 的意思是：</p>
<p><img src="/images/2014/07/15.png" alt=""></p>
<p>选择 <code>Archive</code> 将为程序创建一个 archive。位了创建一个 archive，需要按照上面介绍的，安装一个合适的配置文件。archiving 完成之后，Xcode 将在 Organizer 中显示 archive：</p>
<p><img src="/images/2014/07/16.png" alt=""></p>
<hr>
<p>点击 <code>Distribute...</code>，选择 <code>Save for Enterprise or Ad Hoc Deployment</code>：</p>
<p><img src="/images/2014/07/17.png" alt=""></p>
<p>接着在下拉列表中选择之前创建的配置文件：</p>
<p><img src="/images/2014/07/18.png" alt=""></p>
<p>接下来的界面中，勾选上 <code>Save for Enterprise Distribution</code>。将会呈现出一些文本框，此处允许你输入一些信息，这些信息将被填入程序的 manifest 文件中。这个 manifest 文件是一个 plist 文件，我们可以用文本编辑器对其编辑。所以，这里填错了没关系，稍后可以对其修改。我填入的信息如下所示：</p>
<p><img src="/images/2014/07/19.png" alt=""></p>
<p>上面的 URL 就是 IPA 文件在互联网中可被访问的路径。注意：虽然后面的处理过程都是基于 HTTPS 的，不过 IPA URL 必须是 HTTP。（注释：译者尝试过 IPA 的路径可以是 http 或 https，当然不排除以后苹果会严格限制）。</p>
<hr>
<p>现在，你应该获得了两个文件，IPA 文件和 一个 manifest 文件。将它们上传到服务器上 (一般通过 FTP)，路径就是在 manifest 文件中指定的相关路径 (本示例的路径是 <code>mydomain.com/apps</code>)。现在创建一个 html 文件，文件中包括如下 html 标记：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="operator">a</span> href=<span class="string">"itms-services://?action=download-manifest&url=https://mydomain.com/apps/MyInHouseApp.plist"</span> id=<span class="string">"text"</span>&gt;Install <span class="operator">the</span> In-House App&lt;/<span class="operator">a</span>&gt;</div></pre></td></tr></table></figure>

<p>manifest 文件的路径必须是 <code>HTTPS</code>！将 html 文件跟 IPA 和 manifest 文件一起放置到服务器上。</p>
<p>现在我们来了解一下 HTTPS/SSL：为了能够通过互联网安装 IPA 文件，自从 iOS 7.1 以来，苹果就强制要求，manifest 文件必须通过 HTTPS 方式加载。</p>
<p>为了允许 IPA 文件安装成功，HTTPS 连接需要用 SSL 证书来认证，这个证书是从证书签发中心那里针对域名注册得到的。这样的证书非常的昂贵。不过你都已经为 iOS Enterprise Developer Program 支付了299$，那证书的价格就不算什么了。</p>
<p>为了安装 IPA，我们在 iOS 设备的 Safari 中输入 html 文件的 URL 地址(以 HTTPS 开头)，然后点击链接，并确认安装提示。</p>
<p>如果安装过程中又错误提示框，大多数时候这个错误提示框无法定位具体原因。为了找到错误原因，将 iOS 设备连接到电脑，在 Xcode 中的 Organizer 里面选择对应设备中的 Console，就可以看到并分析相关的日志信息：</p>
<p><img src="/images/2014/07/20.jpg" alt=""></p>
<p>在上面示例中，我试图使用自签名的证书，通过 HTTPS 来安装程序。但是点击连接之后，我遇到了一个错误提示信息：<code>Cannot connect to johannesluderschmidt.de</code>。通过 Xcode 中的 Console，我看到这些信息：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSErrorFailingURLStringKey=http<span class="variable">s:</span>//johannesluderschmidt.de/app/appName.plist, NSUnderlyingError=<span class="number">0</span>x165c7f30 “The certificate <span class="keyword">for</span> this server <span class="keyword">is</span> invalid. You might <span class="keyword">be</span> connecting <span class="keyword">to</span> <span class="keyword">a</span> server that <span class="keyword">is</span> pretending <span class="keyword">to</span> <span class="keyword">be</span> “johannesluderschmidt.de” which could <span class="keyword">put</span> your confidential information at risk.”</div></pre></td></tr></table></figure>

<p>看吧，Safari 给的提示信息很少，但是在 console 中提供的信息就非常有用。</p>
<p>就是这样啦。非常容易，不是吗？我大约用了一天时间，并查阅了 stackoverflow 中的许多文章就搞定在企业内部分发 iOS 应用程序的技术原理了。</p>
<p>希望你也能很快掌握！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="/images/2014/07/01.png" alt=""></p>
]]>
    
    </summary>
    
      <category term="iOS探索" scheme="http://beyondvincent.com/categories/iOS%E6%8E%A2%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[利用长按手势移动 Table View Cells]]></title>
    <link href="http://beyondvincent.com/2014/03/26/2014-03-26-cookbook-moving-table-view-cells-with-a-long-press-gesture/"/>
    <id>http://beyondvincent.com/2014/03/26/2014-03-26-cookbook-moving-table-view-cells-with-a-long-press-gesture/</id>
    <published>2014-03-25T18:30:00.000Z</published>
    <updated>2014-12-31T19:05:45.000Z</updated>
    <content type="html"><![CDATA[<p><img src="/images/2014/03/24.png" alt=""></p>
<a id="more"></a>

<p><img src="/images/2014/03/23.gif" alt=""></p>
<p>本文译自：<a href="http://www.raywenderlich.com/63089/cookbook-moving-table-view-cells-with-a-long-press-gesture" target="_blank" rel="external">Cookbook: Moving Table View Cells with a Long Press Gesture</a></p>
<p>目录：</p>
<ul>
<li>你需要什么？</li>
<li>如何做？</li>
<li>如何将其利用至UICollectionView上？</li>
<li>何去何从？</li>
</ul>
<p>本次的 cookbook-style 教程中介绍如何通过长按手势来移动 table view中的cell，这种操作方式就像苹果自家的天气 App 一样。</p>
<p>你可以直接把本文中的到吗添加到你的工程中，或者将其添加到我为你创建好的 <a href="https://github.com/moayes/UDo/tree/UDo.Starter" target="_blank" rel="external">starter project</a> 中，也可以下载本文的<a href="https://github.com/moayes/UDo/tree/master" target="_blank" rel="external">完整示例工程</a>。</p>
<h2 id="你需要什么？">你需要什么？</h2>
<ul>
<li>UILongGestureRecognizer</li>
<li>UITableView (可以用 UICollectionView 替代之)</li>
<li>UITableViewController (可以用 UIViewController 或 UICollectionViewController 替代之)</li>
<li>5 分钟。</li>
</ul>
<h2 id="如何做？">如何做？</h2>
<p>首先给 table view 添加一个 <code>UILongGestureRecognizer</code>。可以在 table view controller 的 <code>viewDidLoad</code> 方法中添加。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">UILongPressGestureRecognizer *longPress = [[UILongPressGestureRecognizer alloc] </div><div class="line">  initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(longPressGestureRecognized:)];</div><div class="line">[<span class="keyword">self</span><span class="variable">.tableView</span> addGestureRecognizer:longPress];</div></pre></td></tr></table></figure>

<p>记者为 gesture recognizer 添加 action 方法。该方法首先应该获取到在 table view 中长按的位置，然后找出这个位置对应的 cell 的 index。记住：这里获取到的 index path 有可能为 nil(例如，如果用户长按在 table view的section header上)。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">IBAction</span>)longPressGestureRecognized:(<span class="keyword">id</span>)sender {</div><div class="line"> </div><div class="line">  UILongPressGestureRecognizer *longPress = (UILongPressGestureRecognizer *)sender;</div><div class="line">  UIGestureRecognizerState state = longPress<span class="variable">.state</span>;</div><div class="line"> </div><div class="line">  <span class="built_in">CGPoint</span> location = [longPress locationInView:<span class="keyword">self</span><span class="variable">.tableView</span>];</div><div class="line">  <span class="built_in">NSIndexPath</span> *indexPath = [<span class="keyword">self</span><span class="variable">.tableView</span> indexPathForRowAtPoint:location];</div><div class="line"> </div><div class="line">  <span class="comment">// More coming soon...</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>接着你需要处理<code>UIGestureRecognizerStateBegan</code>分支。如果获取到一个有效的 index path(non-nil)，就去获取对应的 <code>UITableViewCell</code>，并利用一个 helper 方法获取这个 table view cell 的 snapshot  view。然后将这个 snapshot  view 添加到 table view 中，并将其 center 到对应的 cell上。</p>
<p>为了更好的用户体验，以及更自然的效果，在这里我把原始 cell 的背景设置为黑色，并给 snapshot  view 增加淡入效果，让 snapshot view 比 原始 cell 稍微大一点，将它的Y坐标偏移量与手势的位置的Y轴对齐。这样处理之后，cell 就像从 table view 中跳出，然后浮在上面，并捕捉到用户的手指。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="built_in">UIView</span>       *snapshot = <span class="literal">nil</span>;        <span class="comment">///&lt; A snapshot of the row user is moving.</span></div><div class="line"><span class="keyword">static</span> <span class="built_in">NSIndexPath</span>  *sourceIndexPath = <span class="literal">nil</span>; <span class="comment">///&lt; Initial index path, where gesture begins.</span></div><div class="line"> </div><div class="line"><span class="keyword">switch</span> (state) {</div><div class="line">  <span class="keyword">case</span> UIGestureRecognizerStateBegan: {</div><div class="line">    <span class="keyword">if</span> (indexPath) {</div><div class="line">      sourceIndexPath = indexPath;</div><div class="line"> </div><div class="line">      <span class="built_in">UITableViewCell</span> *cell = [<span class="keyword">self</span><span class="variable">.tableView</span> cellForRowAtIndexPath:indexPath];</div><div class="line"> </div><div class="line">      <span class="comment">// Take a snapshot of the selected row using helper method.</span></div><div class="line">      snapshot = [<span class="keyword">self</span> customSnapshotFromView:cell];</div><div class="line"> </div><div class="line">      <span class="comment">// Add the snapshot as subview, centered at cell's center...</span></div><div class="line">      __block <span class="built_in">CGPoint</span> center = cell<span class="variable">.center</span>;</div><div class="line">      snapshot<span class="variable">.center</span> = center;</div><div class="line">      snapshot<span class="variable">.alpha</span> = <span class="number">0.0</span>;</div><div class="line">      [<span class="keyword">self</span><span class="variable">.tableView</span> addSubview:snapshot];</div><div class="line">      [<span class="built_in">UIView</span> animateWithDuration:<span class="number">0.25</span> animations:^{</div><div class="line"> </div><div class="line">        <span class="comment">// Offset for gesture location.</span></div><div class="line">        center<span class="variable">.y</span> = location<span class="variable">.y</span>;</div><div class="line">        snapshot<span class="variable">.center</span> = center;</div><div class="line">        snapshot<span class="variable">.transform</span> = CGAffineTransformMakeScale(<span class="number">1.05</span>, <span class="number">1.05</span>);</div><div class="line">        snapshot<span class="variable">.alpha</span> = <span class="number">0.98</span>;</div><div class="line"> </div><div class="line">        <span class="comment">// Black out.</span></div><div class="line">        cell<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> blackColor];</div><div class="line">      } completion:<span class="literal">nil</span>];</div><div class="line">    }</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  }</div><div class="line">  <span class="comment">// More coming soon...</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>将下面的方法添加到 .m 文件的尾部。该方法会根据传入的 view，返回一个对应的 snapshot view。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">UIView</span> *)customSnapshotFromView:(<span class="built_in">UIView</span> *)inputView {</div><div class="line"> </div><div class="line">  <span class="built_in">UIView</span> *snapshot = [inputView snapshotViewAfterScreenUpdates:<span class="literal">YES</span>];</div><div class="line">  snapshot<span class="variable">.layer</span><span class="variable">.masksToBounds</span> = <span class="literal">NO</span>;</div><div class="line">  snapshot<span class="variable">.layer</span><span class="variable">.cornerRadius</span> = <span class="number">0.0</span>;</div><div class="line">  snapshot<span class="variable">.layer</span><span class="variable">.shadowOffset</span> = CGSizeMake(-<span class="number">5.0</span>, <span class="number">0.0</span>);</div><div class="line">  snapshot<span class="variable">.layer</span><span class="variable">.shadowRadius</span> = <span class="number">5.0</span>;</div><div class="line">  snapshot<span class="variable">.layer</span><span class="variable">.shadowOpacity</span> = <span class="number">0.4</span>;</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> snapshot;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>当手势移动的时候，也就是<code>UIGestureRecognizerStateChanged</code>分支，此时需要移动 snapshot view(只需要设置它的 Y 轴偏移量即可)。如果手势移动的距离对应到另外一个 index path，就需要告诉 table view，让其移动 rows。同时，你需要对 data source 进行更新：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> UIGestureRecognizerStateChanged: {</div><div class="line">  <span class="built_in">CGPoint</span> center = snapshot<span class="variable">.center</span>;</div><div class="line">  center<span class="variable">.y</span> = location<span class="variable">.y</span>;</div><div class="line">  snapshot<span class="variable">.center</span> = center;</div><div class="line"> </div><div class="line">  <span class="comment">// Is destination valid and is it different from source?</span></div><div class="line">  <span class="keyword">if</span> (indexPath && ![indexPath isEqual:sourceIndexPath]) {</div><div class="line"> </div><div class="line">    <span class="comment">// ... update data source.</span></div><div class="line">    [<span class="keyword">self</span><span class="variable">.objects</span> exchangeObjectAtIndex:indexPath<span class="variable">.row</span> withObjectAtIndex:sourceIndexPath<span class="variable">.row</span>];</div><div class="line"> </div><div class="line">    <span class="comment">// ... move the rows.</span></div><div class="line">    [<span class="keyword">self</span><span class="variable">.tableView</span> moveRowAtIndexPath:sourceIndexPath toIndexPath:indexPath];</div><div class="line"> </div><div class="line">    <span class="comment">// ... and update source so it is in sync with UI changes.</span></div><div class="line">    sourceIndexPath = indexPath;</div><div class="line">  }</div><div class="line">  <span class="keyword">break</span>;</div><div class="line">}</div><div class="line"><span class="comment">// More coming soon...</span></div></pre></td></tr></table></figure>

<p>最后，当手势结束或者取消时，table view 和 data source 都是最新的。你所需要做的事情就是将 snapshot view 从 table view 中移除，并把 cell 的背景色还原为白色。</p>
<p>为了提升用户体验，我们将 snapshot view 淡出，并让其尺寸变小至与 cell 一样。这样看起来就像把 cell 放回原处一样。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">default</span>: {</div><div class="line">  <span class="comment">// Clean up.</span></div><div class="line">  <span class="built_in">UITableViewCell</span> *cell = [<span class="keyword">self</span><span class="variable">.tableView</span> cellForRowAtIndexPath:sourceIndexPath];</div><div class="line">  [<span class="built_in">UIView</span> animateWithDuration:<span class="number">0.25</span> animations:^{</div><div class="line"> </div><div class="line">    snapshot<span class="variable">.center</span> = cell<span class="variable">.center</span>;</div><div class="line">    snapshot<span class="variable">.transform</span> = CGAffineTransformIdentity;</div><div class="line">    snapshot<span class="variable">.alpha</span> = <span class="number">0.0</span>;</div><div class="line"> </div><div class="line">    <span class="comment">// Undo the black-out effect we did.</span></div><div class="line">    cell<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> whiteColor];</div><div class="line"> </div><div class="line">  } completion:^(<span class="built_in">BOOL</span> finished) {</div><div class="line"> </div><div class="line">    [snapshot removeFromSuperview];</div><div class="line">    snapshot = <span class="literal">nil</span>;</div><div class="line"> </div><div class="line">  }];</div><div class="line">  sourceIndexPath = <span class="literal">nil</span>;</div><div class="line">  <span class="keyword">break</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>就这样，搞定了！编译并运行程序，现在可以通过长按手势对 tableview cells重新排序！</p>
<p>你可以在 GitHub 上下载到<a href="https://github.com/moayes/UDo/tree/master" target="_blank" rel="external">完整的示例工程</a>。</p>
<h2 id="如何将其利用至UICollectionView上？">如何将其利用至UICollectionView上？</h2>
<p>假设你已经有一个示例工程使用了 <code>UICollectionView</code>，那么你可以很简单的就使用上本文之前介绍的代码。所需要做的事情就是用 <code>self.collectionView</code>替换掉 <code>self.tableView</code>，并更新一下获取和移动 <code>UICollectionViewCell</code> 的调用方法。</p>
<p>这里有个练习，从 GitHub上 checkout 出 <a href="https://github.com/moayes/UDo/tree/UDo.UICollectionView.Starter" target="_blank" rel="external">UICollectionView 的starter project</a>，然后将 tap-和-hold 手势添加进去以对 cells 进行重排。这里可以下载到已经实现好了<a href="https://github.com/moayes/UDo/tree/UDo.UICollectionView" target="_blank" rel="external">工程</a>。</p>
<h2 id="何去何从？">何去何从？</h2>
<p>我们深深的希望你喜欢这篇文章！如果以后你想要看到类似更多 cookbook-style 的文章，可以告诉我们。</p>
<p>另外，如果你愿意观看本文的视频版，可以来<a href="http://www.raywenderlich.com/68102/video-tutorial-table-views-moving-rows" target="_blank" rel="external">这里</a>看。</p>
<p>另外，我很乐意听到你的意见和问题！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="/images/2014/03/24.png" alt=""></p>
]]>
    
    </summary>
    
      <category term="iOS探索" scheme="http://beyondvincent.com/categories/iOS%E6%8E%A2%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[减小iOS应用程序的大小]]></title>
    <link href="http://beyondvincent.com/2014/03/24/2014-03-20-reducing-the-size-of-my-app/"/>
    <id>http://beyondvincent.com/2014/03/24/2014-03-20-reducing-the-size-of-my-app/</id>
    <published>2014-03-23T16:20:00.000Z</published>
    <updated>2014-12-31T19:05:45.000Z</updated>
    <content type="html"><![CDATA[<p><img src="/images/2014/03/22.png" alt=""></p>
<a id="more"></a>

<p>本文译自：<a href="https://developer.apple.com/library/ios/qa/qa1795/_index.html#//apple_ref/doc/uid/DTS40014195" target="_blank" rel="external">Reducing the size of my App</a></p>
<p>Q: 怎样才能让我的程序安装包小一点，让程序的下载和安装更快速？</p>
<p>A: 本文收集了一些减小程序安装包大小的相关技巧(当第一次下载和安装程序时)。如果是针对升级程序的话，可以看这篇文章(<a href="https://developer.apple.com/library/ios/qa/qa1779/" target="_blank" rel="external">减小iOS应用程序升级时所需下载的大小</a>)(这与第一次安装使用的工作原理有所不同)。</p>
<h2 id="检查应用程序">检查应用程序</h2>
<p>首先是检查<code>.app bundle</code>，看一下程序包里面哪些文件占的空间最大。</p>
<p>在做任何相关优化之前，我们需要做一些权衡。通过权衡，可以知道把优化的重点集中在什么地方。本文提到的一些技术缺点我们也需要做出考虑，我们必须考虑相关影响，以确保做出正确的决定。如果不做权衡的话，我们无法知道需要对程序做出什么样的改变。</p>
<p>当第一安装iOS程序时，需要下载完整的一个<code>.ipa</code>文件。(注意这<a href="https://developer.apple.com/library/ios/qa/qa1779/" target="_blank" rel="external">不同于升级</a>)。实际上<code>.ipa</code>文件就是一个<code>.zip</code>结构。</p>
<p>我们可以通过这样的方法来找出程序的<code>.ipa</code>文件：从App Store下载应用，然后利用iTunes对iOS设备做同步处理，接着查看目录：<code>~/Music/iTunes/iTunes Music/Mobile Applications</code>，就能找到<code>.ipa</code>文件了。</p>
<p>当让我们也可以通过使用: <a href="https://developer.apple.com/library/ios/qa/qa1764/" target="_blank" rel="external">Xcode的Archive命令来构造出<code>.ipa</code>文件——该文件与提交到App Store上的格式基本一致</a>。</p>
<h3 id="检查-ipa文件">检查<code>.ipa</code>文件</h3>
<p>简单的将后缀为<code>.ipa</code>文件修改为<code>.zip</code>，然后利用Finder将其解压出来。右键单击解压出来的<code>.app bundle</code>，选择<code>显示包内容</code>，以查看里面的资源文件。通过该方法我们可以看到哪些文件占的空间最大。记住：<code>.app bundle</code>是经过压缩的，并且有些文件的压缩效果要比别的文件好，所以压缩后的效果才是才是最重要的。不过一般情况下在压缩前最大的文件，在压缩后依旧是最大的文件。我们可以将某个文件删除，然后在Finder中右键单击，选择<code>压缩</code>，这样可以更加精确的测量文件压缩效果。</p>
<h3 id="iOS_App_Store相关因素">iOS App Store相关因素</h3>
<p>作为提交到App Store中app里的可执行文件是被加过密的。加密的副作用是可执行文件的压缩效果没有之前的好了，因为加密会隐藏一些细节问题。因此，从App Store下载下来的.ipa文件大小要比从本地build出来的.ipa文件大。</p>
<p>注意：将<code>长文本内容</code>和<code>表数据</code>等从代码中移除，并添加到外部文件中，这样可以减小最终安装包下载的大小——因为这些文件的压缩效果更好。</p>
<p>如果你选择Organizer window中的某个archived，然后点击<code>Estimate Size</code>，Xcode可以对最终分发的程序尺寸做出一个评估。这里并不考虑Mac App Store上面的和企业级部署的iOS程序。</p>
<h2 id="Build_Settings">Build Settings</h2>
<h3 id="编译选项">编译选项</h3>
<p>将build setting中的<code>Optimization Level</code>设置为<code>Fastest, Smallest [-Os]</code>; 将build setting 中的<code>Strip Debug Symbols During Copy</code>设置为<code>YES</code>(COPY_PHASE_STRIP = YES)，这样可以减小编译出二进制文件的尺寸。这里提到的这些设置在Xcode工程中对于<code>Release</code>的配置是默认的。</p>
<p>警告：这些设置会让你的程序很难debug。在一般开发环境build中不建议这样设置，</p>
<h3 id="Target针对较少的CPUs">Target针对较少的CPUs</h3>
<p>默认情况下，Xcode工程都配置为：对程序指定的特定CPU类型做优化处理，以生成相对于的可执行文件。不同的硬件，将运行不同的可执行代码。虽然这样优化后的程序，只能针对某些设备运行，但是这大大减小可执行程序的大小。</p>
<p>要想只设定特定类型的CPUs，可以修改build setting中的<code>Architectures</code>，将其从<code>Standard $(ARCHS_STANDARD)</code>修改为你希望支持的列表中对应的特定类型CPU。有效的CPU名称列在<code>Valid Architectures (VALID_ARCHS)</code> build setting中。请不要修改<code>Valid Architectures</code>设置项，最好由Xcode管理。</p>
<h2 id="Assets">Assets</h2>
<h3 id="对应用程序做一个完整性检查">对应用程序做一个完整性检查</h3>
<p>利用<a href="https://developer.apple.com/library/ios/qa/qa1795/_index.html#//apple_ref/doc/uid/DTS40014195-CH1-MEASURE" target="_blank" rel="external">Inspecting Your App</a>中介绍的流程，对.app bundle做一个全面的检查，以了解那些是真正需要用到的。在程序中，经常会包含一些额外的文件，例如readme之类的，这些从来都不会被用到。</p>
<h3 id="将数据从代码中剥离出来">将数据从代码中剥离出来</h3>
<p>将所有的资源(例如很长的字符串)从代码中剥离出来，并存入外部文件，这样会减小最终文件下载的大小，因为这些文件的压缩效果更好。(参考<a href="https://developer.apple.com/library/ios/qa/qa1795/_index.html#//apple_ref/doc/uid/DTS40014195-CH1-FAIRPLAY" target="_blank" rel="external">iOS App Store Specific Considerations</a>中的完整介绍。)</p>
<h2 id="Image_Assets">Image Assets</h2>
<h3 id="尽量使用8-bit图片">尽量使用8-bit图片</h3>
<p>使用8-bit的PNG图片，比32-bit的图片能减少4倍的压缩率。由于8-bit的图片支持最多256种不同的颜色，所以8-bit的图片一般只应该用于一小部分的颜色图片。例如灰度图片最好使用8-bit。</p>
<h3 id="针对32-bit的图片尽量使用高压缩的比率">针对32-bit的图片尽量使用高压缩的比率</h3>
<p>利用Adobe Photoshop的<code>Save For Web</code>可以减小JPEG和PNG的图片大小。在Xcode中，默认情况下，会自动的使用<a href="https://developer.apple.com/library/ios/qa/qa1681/" target="_blank" rel="external">pngcrush</a>来压缩.png图片。</p>
<h2 id="Audio_Assets">Audio Assets</h2>
<h3 id="音频的压缩">音频的压缩</h3>
<p>参考WWDC中的<a href="https://developer.apple.com/videos/wwdc/2011/?id=404" target="_blank" rel="external">Audio Development for Games</a>，里面介绍了如何有效的处理音频。常规来说，我们要使用AAC或MP3来压缩音频，并且可以尝试降低一下音频的比特率。有时候44.1khz的采样是没有必要的，稍微低一点的比特率也不会降低音频的质量。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="/images/2014/03/22.png" alt=""></p>
]]>
    
    </summary>
    
      <category term="iOS探索" scheme="http://beyondvincent.com/categories/iOS%E6%8E%A2%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[提高Interface Builder高效工作的8个技巧]]></title>
    <link href="http://beyondvincent.com/2014/03/19/2014-03-18-18-tips-for-working-effectively-with-interface-builder/"/>
    <id>http://beyondvincent.com/2014/03/19/2014-03-18-18-tips-for-working-effectively-with-interface-builder/</id>
    <published>2014-03-18T16:10:00.000Z</published>
    <updated>2014-12-31T19:05:45.000Z</updated>
    <content type="html"><![CDATA[<p><img src="/images/2014/03/21.png" alt=""></p>
<a id="more"></a>

<p>本文译自：<a href="http://codesheriff.blogspot.com/2014/03/8-tips-for-working-effectively-with.html" target="_blank" rel="external">8 Tips for working effectively with Interface Builder</a>(需翻墙)</p>
<p>先来看看目录：</p>
<ol>
<li>介绍</li>
<li>使view的Size与view中的Content相适应 </li>
<li>按住option键—观察所选中view与另外view边缘之间的距离</li>
<li>Editor -&gt; Embed In View, Unembed:</li>
<li>在不影响subview的位置时给view自由的添加padding</li>
<li>对不在最前端的view进行移动</li>
<li>IBOutletCollection排序</li>
<li>使用自定义属性</li>
<li>MoarFonts——字体定制：所见即所得</li>
</ol>
<h2 id="介绍">介绍</h2>
<p>在JoyTunes工作期间，我们在开发最新一版的钢琴应用程序，对程序的UI做了大量的重新设计，因而也在Interface Builder上花费了许多时间，对于图片和view的缩放操作，非常的让人不省心。不过在开发过程中，我们发现了许多非常不错的IB使用技巧，我寻思着这必须要跟大家分享，所以成就了这篇文章。</p>
<p>免责声明：<br>在JoyTune工作期间，我们使用的是.xib文件(不是storyboards)，并且没有使用Auto Layout。实际上这主要是历史原因导致的。所以，这里介绍的一些技巧可能稍微有点不同(如果你使用storyboard或Auto Layout)，不过大多数都是一样的。</p>
<h2 id="1-_使view的Size与view中的Content相适应">1. 使view的Size与view中的Content相适应</h2>
<p>很惭愧的是最近才发现这个功能——能节约大量时间。<br>选中任意的一个view，然后Editor-&gt;Size to Fit Content，或者简单的按 ⌘=<br>接着就会按照下面的规则对选中view的Size做出与之Content对应的适应。</p>
<ul>
<li>ImageView/Button的size会设置为图像的原始size(最常见的用法)：</li>
</ul>
<p><img src="/images/2014/03/12.gif" alt=""></p>
<ul>
<li>Label/Button的size会被设置为与当前text内容相当的尺寸：</li>
</ul>
<p><img src="/images/2014/03/13.gif" alt=""></p>
<ul>
<li>parent container view会与其subviews的frames相适应。</li>
</ul>
<p><img src="/images/2014/03/14.gif" alt=""></p>
<h2 id="2-_按住option键—观察所选中view与另外view边缘之间的距离">2.  按住option键—观察所选中view与另外view边缘之间的距离</h2>
<p>按住option键之后，选择一个view，然后将鼠标悬停在别的一些view上，会看到一些距离——选中view与别的view边缘之间的距离。</p>
<p><img src="/images/2014/03/15.gif" alt=""></p>
<h2 id="3-_Editor_-&gt;_Embed_In_View,_Unembed:">3. Editor -&gt; Embed In View, Unembed:</h2>
<p>你是不是对此素手无策呢：你希望将已有的一些subviews放入到不同的parent view中，甚至是不同的.xib文件中，但是当你把一些view重新设置之后，它们为自动的位于新的parent view中心？</p>
<p>现在好了，我们有一个解决办法，如下图所示：</p>
<p><img src="/images/2014/03/16.gif" alt=""></p>
<h2 id="4-_在不影响subview的位置时给view自由的添加padding">4. 在不影响subview的位置时给view自由的添加padding</h2>
<p>当试图给view添加padding时，默认情况下subview的x和y是不会改变的，但是有时候我们并不希望是这样的结果。我发现一个最好的方法，就是在按住⌘时拖动view的边缘：</p>
<p><img src="/images/2014/03/17.gif" alt=""></p>
<h2 id="5-_对不在最前端的view进行移动">5. 对不在最前端的view进行移动</h2>
<p>刚开始我还以为要想移动不在最前端的view是不可行的。</p>
<p>有一种方法就是先将非最前端的view临时设置到最前端，移动好位置之后，在设置回去。</p>
<p>另外一种方法就是使用右边panel中的size inspector，不过有时候要想设置一个好的位置，需要不断的猜测和修正。</p>
<p>另外我发现一种方法：使用键盘上的上下左右键来移动view——这还不用把view设置为最前端：</p>
<ul>
<li>在document outline中选中view</li>
<li>为了获得view的焦点：单击root view的frame</li>
<li>利用箭头进行移动</li>
</ul>
<p><img src="/images/2014/03/18.gif" alt=""></p>
<p>提醒：<br>获得view的焦点还有一个更好的方法：在document outline上双击view，就可以用箭头移动view了。</p>
<h2 id="6-_IBOutletCollection排序">6. IBOutletCollection排序</h2>
<p>有时候IBOutletCollection里面元素的顺序对我们来说非常重要：我们希望按某个顺序对其进行迭代。</p>
<p>有一种方法：在代码里面利用x/y/tag对其做排序处理，然后在迭代。</p>
<p>实际上，没必要这么做。IBOutletCollection的顺序取决于我们dragged connection的顺序，可以通过^+单击 File’s Owner来查看当前的顺序：</p>
<p><img src="/images/2014/03/19.gif" alt=""></p>
<h2 id="7-_使用自定义属性">7. 使用自定义属性</h2>
<p>可能这个功能是IB中很少被使用的：使用Identity inspector中的User Defined Runtime Attributes(用户自定义运行时属性)在view上设置自定义属性：</p>
<p><img src="/images/2014/03/20.gif" alt=""></p>
<p>在此我定义了一个JTLabel类，我们可以设置它的stroke color和width，这样一来我们就不用在代码里面设置相关属性了。</p>
<p>利用这个功能很好的一例子就是<a href="http://canvaspod.io/" target="_blank" rel="external">Canvas</a>，通过它不用写一行代码就能定义相关的动画。</p>
<h2 id="8-_MoarFonts——字体定制：所见即所得">8. MoarFonts——字体定制：所见即所得</h2>
<p>在Interface Builder中字体的定制是个非常麻烦的事情。IB并没有内置该功能，我用过比较好的解决办法就是使用自定义属性——就像Canvas一样，或者使用字体替换技术——例如<a href="https://github.com/deni2s/IBCustomFonts" target="_blank" rel="external">IBCustomFonts</a>。这些都是有效的方案，不过他们有一个致命的缺点——它们不能给我们一种WYSIWYG(所见即所得)的体验，当然，这也是为什么我们会第一时间使用Interface Builder的原因。</p>
<p>为了知道给label设置的自定义字体是否合适，我们必须要运行程序才能知道结果——这有点让人不能接受。</p>
<p>最近我发现了一个新的解决办法：使用<a href="http://pitaya.ch/moarfonts/" target="_blank" rel="external">MoarFonts</a>。卖价10美元，没有demo，没有试用——不过请相信，这非常值得购买！它的使用方法非常简单：将MoarFonts当做script build phase，然后build app，接着重启Xcode，就可在Interface Builder中看到定制的字体。</p>
<p>打完收工！希望这些技巧对你能有所帮助。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="/images/2014/03/21.png" alt=""></p>
]]>
    
    </summary>
    
      <category term="iOS探索" scheme="http://beyondvincent.com/categories/iOS%E6%8E%A2%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在iOS上使用自签名的SSL证书]]></title>
    <link href="http://beyondvincent.com/2014/03/17/2014-03-17-five-tips-for-using-self-signed-ssl-certificates-with-ios/"/>
    <id>http://beyondvincent.com/2014/03/17/2014-03-17-five-tips-for-using-self-signed-ssl-certificates-with-ios/</id>
    <published>2014-03-17T06:15:00.000Z</published>
    <updated>2014-12-31T19:05:45.000Z</updated>
    <content type="html"><![CDATA[<p><img src="/images/2014/03/09.png" alt=""></p>
<a id="more"></a>

<p>本文译自：<a href="http://blog.httpwatch.com/2013/12/12/five-tips-for-using-self-signed-ssl-certificates-with-ios/" target="_blank" rel="external">Five Tips for Using Self Signed SSL Certificates with iOS</a></p>
<p>小引：</p>
<p>上周苹果release了iOS 7.1，用户升级至此版本，去下载企业级应用时，如果应用不是用https部署的，那么会提示服务器上的证书无效，如下图所示：</p>
<p><img src="/images/2014/03/11.PNG" alt=""></p>
<p>小引:</p>
<p>在iOS 7.1中需要将plists文件的url路径设置为https才能下载安装，如果之前是用http部署的，这就需要对服务器做一些修改。网上流传着(<a href="http://stackoverflow.com/questions/20276907/enterprise-app-deployment-doesnt-work-on-ios-7-1/22325916#22325916" target="_blank" rel="external">Enterprise app deployment doesn’t work on iOS 7.1</a>)把plist放到公开的具有https功能的文件服务器上即可(dropbox或SkyDrive)，经试验，都是可行的。不过如要企业内部的网络无法访问外网，这又如何是好呢？网上也流传需要受信任的证书才行，这样一来对于某些企业的内部部署就比较麻烦了(局域网、主机名变动等都会引起很麻烦的事情)，各区域可能还要用不同的证书(对应不同的host name)。</p>
<p>经查苹果的相关文档(2014年2月份)，是可以使用http或者https的，后来打电话咨询苹果技术支持人员，告知文档还没来得及更新，不过自签名的证书也可以使用，最好首先要把证书(最好是CA根证书)通过mail或者配置工具安装到iOS设备上，然后根据这个CA构建web 服务器上用到的证书，这样当iOS设备访问web服务器来安装app时，就可以正常进行了。这样的话，我们只需要根据不同的服务器制作对应的自签名证书即可，有问题也方便修改跟进。</p>
<p>下面这篇文章就是介绍如何在iOS上面使用自签名的SSL证书。</p>
<p>先来看看目录：</p>
<ol>
<li>在iPhone或者iPad上的Safari中不要接受自签名证书</li>
<li>像安装iOS的Configuration Profile一样安装自签名证书</li>
<li>不要用IIS创建自签名证书</li>
<li>利用OpenSSL创建自签名证书</li>
<li>创建自己的证书颁发机构(CA)</li>
</ol>
<p>虽说SSL证书的购买价格不是太贵，不过有时候我们自行创建的话要更加方便一些，例如我们需要在开发环境配置SSL时、我们的测试服务器有不同的主机名或者开发的系统只有本地局域网才能访问。</p>
<p>实际上我们可以免费的创建<a href="http://en.wikipedia.org/wiki/Self-signed_certificate" target="_blank" rel="external">自签名SSL证书</a>，并不需要给证书颁发机构(CA)支付任何费用，也不需要遵守任何审计要求。</p>
<p>使用自签名SSL证书的缺点就是浏览器不会自动的信任相关的站点。如果用iPhone或者iPad上的Safari打开相关站点，会看到如下提示界面：</p>
<p><img src="/images/2014/03/01.png" alt=""></p>
<p>这里的HttpWatch iOS app还会有更详细的提示内容：</p>
<p><img src="/images/2014/03/02.png" alt=""></p>
<p>本文剩余内容将介绍如何对iOS做配置，以避免上面遇到的问题，以及如何方便的创建和管理自签名证书。</p>
<h2 id="在iPhone或者iPad上的Safari中不要接受自签名证书">在iPhone或者iPad上的Safari中不要接受自签名证书</h2>
<p>当在Safari中第一次访问自签名证书的站点时，会有如下提示(Continue或Details-&gt;Accept)：</p>
<p><img src="/images/2014/03/03.png" alt=""></p>
<p>如果你照着选择的话，是可以在Safari中打开站点的，不过这样会有两个明显的缺点：</p>
<ol>
<li>在Safari中接受证书只会添加一个<code>SSL例外</code>：防止Safari对此站点做出的警告提示。实际上并不会将证书安装到iOS中，以成为可信任的证书。同台设备的其它程序在连接该站点时仍然会失败。</li>
<li>一旦将<code>SSL例外</code>添加到iOS 7中了，就无法从iOS 7中移除。在之前的版本还可以通过Settings-&gt;Safari，选中”Clear Cookies and Data”进行删除。在iOS 7中这好像没有效果。———除非<code>General &gt; Reset &gt; Reset Settings</code>。</li>
</ol>
<p>当然，苹果官方也提供了一个工具<a href="http://support.apple.com/downloads/#iphone%20configuration%20utility" target="_blank" rel="external">iPhone configuration utility for Mac and PC</a>，通过该工具可以把证书安装至设备中。如果邮件不可用，或者要批量安装的话，这是一个好方法。</p>
<h2 id="像安装iOS的Configuration_Profile一样安装自签名证书">像安装iOS的Configuration Profile一样安装自签名证书</h2>
<p>要想把SSL证书在iOS设备上安装为可信任的，可以通过发邮件到设备上，并将证书以附件的形式带在邮件中：</p>
<p><img src="/images/2014/03/04.png" alt=""></p>
<p>选择邮件中的附件，以将证书安装至iOS设备中。选择附件之后，选择<code>Install</code>来安装证书。完成安装之后，再在Safari或者其它iOS应用中使用该证书时，就不会有相关提醒了。</p>
<p>并且这与Safari添加的<code>SSL例外</code>有一个很大的区别，你可以在任意时刻通过<code>Settings-&gt;General-&gt;Profiles</code>来查看相关证书，如果有必要的话，还可以将其移除：</p>
<p><img src="/images/2014/03/05.png" alt=""></p>
<p>当然，苹果也提供了一个工具<a href="http://support.apple.com/downloads/#iphone%20configuration%20utility" target="_blank" rel="external">iPhone configuration utility for Mac and PC</a>，通过该工具可以把证书安装到设备中，如果邮件不可用，或者要批量安装证书的话，可以用这个工具。</p>
<h2 id="不要用IIS创建自签名证书">不要用IIS创建自签名证书</h2>
<p>在IIS中创建自签名证书非常的简单。只需要选择菜单中的<code>Create Self-Signed Certificate</code>即可：</p>
<p><img src="/images/2014/03/06.png" alt=""></p>
<p>不过IIS简单的使用计算机名称当做证书的主机名：</p>
<p><img src="/images/2014/03/07.png" alt=""></p>
<p>大多数时候，计算机名称与主机名是不匹配的，这样的话自签名的证书永远都不会受信任——即使已经安装至iOS设备中：</p>
<p><img src="/images/2014/03/08.png" alt=""></p>
<p>要修复这个问题可以安装并运行IIS 6 Toolkit中的SelfSSL。不过，要是使用OpenSSL则非常简单，下面我们就来看看吧。</p>
<h2 id="利用OpenSSL创建自签名证书">利用OpenSSL创建自签名证书</h2>
<p>创建自签名证书最简单的一种方法就是使用<a href="http://www.openssl.org/related/binaries.html" target="_blank" rel="external">OpenSSL命令行工具</a>，这个工具在许多平台上面都可以使用，并且在Mac OSX上面是默认安装好了的。</p>
<p>首先，创建一个私钥文件：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">openssl genrsa -<span class="keyword">out</span> myselfsigned.key <span class="number">2048</span></div></pre></td></tr></table></figure>

<p>然后创建自签名证书：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">openssl req -<span class="keyword">new</span> -x509 -<span class="keyword">key</span> myselfsigned.<span class="keyword">key</span> -out myselfsigned.cer -days <span class="number">365</span></div><div class="line">-subj /CN=www.mysite.com</div></pre></td></tr></table></figure>

<p>上面的命令中，关于私钥和证书(cer)的文件名可以是任意的。其中<code>CN</code>参数需要设置为主机名(例如<a href="https://www.mysite.com)。而`days`参数则指定证书从创建开始的有效天数。" target="_blank" rel="external">https://www.mysite.com)。而`days`参数则指定证书从创建开始的有效天数。</a></p>
<p>在Apache服务器上面可以直接使用私钥和证书文件(做相关的SSL配置即可)。在IIS中需要一个PFX文件，通过该文件，可以将证书导入至IIS的Server Certificates中。当然通过OpenSSL可以创建PFX文件：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">openssl pkcs12 -<span class="keyword">export</span> -<span class="keyword">out</span> myselfsigned.pfx -inkey myselfsigned.key</div><div class="line">-<span class="keyword">in</span> myselfsigned.cer</div></pre></td></tr></table></figure>

<h2 id="创建自己的证书颁发机构(CA)">创建自己的证书颁发机构(CA)</h2>
<p>使用自签名证书会有这样的问题：需要为每台设备中用到的每个证书设置相关的信任关系。有一个解决办法就是创建自己的证书颁发机构(CA)根证书，然后基于该根证书创建别的证书。</p>
<p>这样一来就是自己扮演着CA，取代了商业性质的CA。这样做的好处就是自己的CA证书只需要在每台设备上安装一次即可。之后，设备会自动的信任基于CA根证书创建的证书。</p>
<p>创建CA证书只需要两个步骤即可，首先是创建私钥文件(跟之前的一样)：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">openssl genrsa -<span class="keyword">out</span> myCA.key <span class="number">2048</span></div></pre></td></tr></table></figure>

<p>然后是创建证书：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">openssl req -x509 -<span class="keyword">new</span> -<span class="keyword">key</span> myCA.<span class="keyword">key</span> -out myCA.cer -days <span class="number">730</span></div><div class="line">-subj /CN=<span class="string">"My Custom CA"</span></div></pre></td></tr></table></figure>

<p>上面创建的证书(myCA.key)可以公开发布出去，并安装在iOS或者其它OS上，以此当做内置的受信任根CA。自制的CA证书存储在<code>General-&gt;Settings-&gt;Profile</code>：</p>
<p><img src="/images/2014/03/10.png" alt=""></p>
<p>其中私钥文件(myCA.key)只用是再创建新的SSL证书时使用。</p>
<p>上面的CA创建好之后，我们可以基于该证书创建许多证书。注意，这里多了一个步骤：必须创建一个CSR(客户端证书请求文件)——就像购买商业的SSL证书一样。</p>
<p>首先需要创建一个私钥文件：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">openssl genrsa -<span class="keyword">out</span> mycert1.key <span class="number">2048</span></div></pre></td></tr></table></figure>

<p>然后是创建CSR:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">openssl req -<span class="keyword">new</span> -out mycert1.req -<span class="keyword">key</span> mycert1.<span class="keyword">key</span> -subj /CN=www2.mysite.com</div></pre></td></tr></table></figure>

<p>接着用这个CSR创建证书：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">openssl x509 -req -<span class="keyword">in</span> mycert1.req -<span class="keyword">out</span> mycert1.cer -CAkey myCA.key</div><div class="line">-CA myCA.cer -days <span class="number">365</span> -CAcreateserial -CAserial serial</div></pre></td></tr></table></figure>

<p>这里创建的证书(mycert.cer)可以安装在一台web服务器上，并且已经安装了相关CA证书的iOS设备都可以访问该web服务器。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="/images/2014/03/09.png" alt=""></p>
]]>
    
    </summary>
    
      <category term="iOS探索" scheme="http://beyondvincent.com/categories/iOS%E6%8E%A2%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Core Bluetooth介绍：构建一个心率监测器]]></title>
    <link href="http://beyondvincent.com/2014/02/20/2014-02-20-introduction-core-bluetooth-building-heart-rate-monitor/"/>
    <id>http://beyondvincent.com/2014/02/20/2014-02-20-introduction-core-bluetooth-building-heart-rate-monitor/</id>
    <published>2014-02-20T12:20:00.000Z</published>
    <updated>2014-12-31T19:05:45.000Z</updated>
    <content type="html"><![CDATA[<p><img src="/images/2014/02/1.png" alt=""></p>
<a id="more"></a>

<p>本文译自：<a href="http://www.raywenderlich.com/52080/introduction-core-bluetooth-building-heart-rate-monitor" target="_blank" rel="external">Introduction to Core Bluetooth: Building a Heart Rate Monitor</a></p>
<ul>
<li>蓝牙中的中心和外设</li>
<li>中心如何与外设通讯</li>
<li>外设数据的结构</li>
<li>CBPeripheral CBService 和 CBCharacteristic</li>
<li>开始</li>
<li>相关Delegate</li>
<li>用户界面的构建</li>
<li>利用Bluetooth框架</li>
<li>实现Delegate方法<ul>
<li>添加centralManagerDidUpdateState:central</li>
<li>添加didDiscoverPeripheral:peripheral:</li>
<li>添加centralManager:central:peripheral:</li>
<li>添加peripheral:didDiscoverServices:</li>
<li>添加peripheral:didDiscoverCharacteristicsForService:</li>
<li>添加peripheral:didUpdateValueForCharacteristic:</li>
<li>添加getHeartRateBPM:(CBCharacteristic <em>)characteristic error:(NSError </em>)error</li>
<li>添加getManufacturerName:(CBCharacteristic *)characteristic</li>
<li>添加getBodyLocation:(CBCharacteristic *)characteristic</li>
</ul>
</li>
<li>让心跳再快一点</li>
<li>何去何从？</li>
</ul>
<p>在iOS和Mac程序开发中，通过Core Bluetooth可以与低功耗的蓝牙设备(BLE)通信。BLE包括心率监测器、数字温度计等。</p>
<p>Core framework 根据<a href="https://www.bluetooth.org/en-us/specification/adopted-specifications" target="_blank" rel="external">蓝牙4.0的规范</a>做了封装，并定义了一套易于使用的protocol——用于与BLE设备通讯。</p>
<p>通过本文，可以学习关于Core Bluetooth框架的关键内容，以及如何利用框架搜索和连接至BLE设备，并获取到相关数据。本文我将构建一个心率监测程序，让其与蓝牙心率监测器通讯。</p>
<p>本文使用的心率监测器是<a href="http://amzn.to/1h6RjLY" target="_blank" rel="external">Polar H7 Bluetooth Smart Heart Rate Sensor</a>。如果你没有这种蓝牙设备的话，也可以继续学习本文，只不过在自己使用的时候，有些代码需要微调一下。</p>
<h1 id="蓝牙中的中心和外设">蓝牙中的中心和外设</h1>
<p>在所有的Bluetooth Le通讯中又两个主要的角色：中心和外设：</p>
<ul>
<li><code>中心</code>可以理解为boss。他希望从一帮工人手里获取到一些信息，已完成特定的任务。</li>
<li><code>外设</code>可以理解为worker。它负责收集和发布数据。</li>
</ul>
<p>下面这个图可以看到它们之间的关系：</p>
<p><img src="/images/2014/02/3.png" alt=""></p>
<p>在上面的场景中，一台iOS设备(中心)与心率监测器(外设)通讯，以获取到相关数据，并显示到程序界面上。</p>
<h1 id="中心如何与外设通讯">中心如何与外设通讯</h1>
<h1 id="外设数据的结构">外设数据的结构</h1>
<h1 id="CBPeripheral_CBService_和_CBCharacteristic">CBPeripheral CBService 和 CBCharacteristic</h1>
<h1 id="开始">开始</h1>
<h1 id="相关Delegate">相关Delegate</h1>
<h1 id="用户界面的构建">用户界面的构建</h1>
<h1 id="利用Bluetooth框架">利用Bluetooth框架</h1>
<h1 id="实现Delegate方法">实现Delegate方法</h1>
<h2 id="添加centralManagerDidUpdateState:central">添加centralManagerDidUpdateState:central</h2>
<h2 id="添加didDiscoverPeripheral:peripheral:">添加didDiscoverPeripheral:peripheral:</h2>
<h2 id="添加centralManager:central:peripheral:">添加centralManager:central:peripheral:</h2>
<h2 id="添加peripheral:didDiscoverServices:">添加peripheral:didDiscoverServices:</h2>
<h2 id="添加peripheral:didDiscoverCharacteristicsForService:">添加peripheral:didDiscoverCharacteristicsForService:</h2>
<h2 id="添加peripheral:didUpdateValueForCharacteristic:">添加peripheral:didUpdateValueForCharacteristic:</h2>
<h2 id="添加getHeartRateBPM:(CBCharacteristic_)characteristic_error:(NSError_)error">添加getHeartRateBPM:(CBCharacteristic <em>)characteristic error:(NSError </em>)error</h2>
<h2 id="添加getManufacturerName:(CBCharacteristic_*)characteristic">添加getManufacturerName:(CBCharacteristic *)characteristic</h2>
<h2 id="添加getBodyLocation:(CBCharacteristic_*)characteristic">添加getBodyLocation:(CBCharacteristic *)characteristic</h2>
<h1 id="让心跳再快一点">让心跳再快一点</h1>
<h1 id="何去何从？">何去何从？</h1>
<p>至此，你已经学习了Core Bluetooth LE相关内容，以及如何使用其来连接到低功耗蓝牙外设，并获取到相关数据。</p>
<p>关于Core Bluetooth设备的另外一个示例是iBeacons。如果你感兴趣的话，可以看看<a href="http://www.raywenderlich.com/store/ios-7-by-tutorials" target="_blank" rel="external">iOS 7 by Tutorials</a>中的<code>What&#39;s New in Core Location</code>章节。</p>
<p>可以来这里下载本文涉及到的<a href="http://cdn4.raywenderlich.com/wp-content/uploads/2013/12/HeartMonitor-Final.zip" target="_blank" rel="external">完整示例工程</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="/images/2014/02/1.png" alt=""></p>
]]>
    
    </summary>
    
      <category term="iOS探索" scheme="http://beyondvincent.com/categories/iOS%E6%8E%A2%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[推荐一本好书：MacTalk 人生元编程]]></title>
    <link href="http://beyondvincent.com/2014/02/13/2014-02-13-about-mactalk/"/>
    <id>http://beyondvincent.com/2014/02/13/2014-02-13-about-mactalk/</id>
    <published>2014-02-13T09:45:00.000Z</published>
    <updated>2014-12-31T19:05:45.000Z</updated>
    <content type="html"><![CDATA[<p><img src="/images/2014/02/1.png" alt=""></p>
<a id="more"></a>

<p>今天给大家推荐一本来自池建强的好书：MacTalk 人生元编程。</p>
<p><img src="/images/2014/02/2.png" alt=""></p>
<p>该书内容以技术+人文为主。既然是MacTalk，那当然会有Mac相关内容介绍啦，该书开头部分就介绍了Mac的一些知识，其中关于Mac的历史演变，曾经是在池院长的微信公众账号上看到的，非常的干货，实在！</p>
<p>随后是介绍一些程序员与编程相关知识，里面有一篇文章是介绍<code>程序员如何提高英语阅读水平</code>，如果你还在努力提升英语阶段，相信对你有用。里面的另外的一篇文章<code>如何学习一门编程语言</code>也介绍得非常全面，具体内容可以到书里面看哟。</p>
<p>相信要是写程序的话，大多数开发者都不在话下，即使有一定的难度，但是要让程序员写一些科技与人文相关的内容，就比较困难了，这需要很深厚的文化底蕴和勇气，写得不好，会引来大量的砖块，相反，自然会赢得口碑，就如本书一样。文中参杂着池院长的风雨经历，例如<code>缅怀那些沉没的项目</code>，让读者读起来有大快人心的感觉，或许还能产生共鸣。</p>
<p>书中的最后还介绍了一些职场相关的知识，都是干货呀！！！</p>
<p>你是否也去买一本呢：<a href="http://item.jd.com/11398297.html" target="_blank" rel="external">传送门在这里</a>。</p>
<p>关于作者的更多介绍，<a href="http://macshuo.com/" target="_blank" rel="external">可以来这里看</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="/images/2014/02/1.png" alt=""></p>
]]>
    
    </summary>
    
      <category term="杂集" scheme="http://beyondvincent.com/categories/%E6%9D%82%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS 7中实现模糊效果]]></title>
    <link href="http://beyondvincent.com/2014/01/29/2014-01-29-ios-7-blur-effects-gpuimage/"/>
    <id>http://beyondvincent.com/2014/01/29/2014-01-29-ios-7-blur-effects-gpuimage/</id>
    <published>2014-01-29T11:10:00.000Z</published>
    <updated>2014-12-31T19:05:45.000Z</updated>
    <content type="html"><![CDATA[<p><img src="/images/2014/01/42.png" alt=""></p>
<a id="more"></a>

<p>本文译自<a href="http://www.raywenderlich.com/60968/ios-7-blur-effects-gpuimage" target="_blank" rel="external">iOS 7 Blur Effects with GPUImage</a>。</p>
<p>iOS 7在视觉方面有许多改变，其中非常吸引人的功能之一就是在整个系统中巧妙的使用了模糊效果。许多第三方应用程序已经采用了这样的设计细节，并以各种奇妙的和具有创造性的方式使用它。</p>
<p>本文将通过几种不同的技术来实现iOS 7中的模糊效果，当然，这一切都利用了一个名为<a href="https://github.com/BradLarson/GPUImage" target="_blank" rel="external">GPUImage</a>的框架。</p>
<p><code>GPUImage</code>是由<a href="http://www.sunsetlakesoftware.com/blog" target="_blank" rel="external">Brad Larson</a>创建的，它利用GPU，使在图片和视频上应用不同的效果和滤镜变得非常的容易，同时它还拥有出色的性能，并且它的性能要比苹果内置的相关APIs出色。</p>
<p><code>注意：本文需要一台物理设备来编译并运行示例程序(在模拟器上无法使用)。同样还需要一个iOS开发者账号。如果你还没有开发者账号的话，可以来[这里](https://developer.apple.com/)注册一个。注册为开发者之后，会有许多福利哟，例如可以使用物理设备来开发程序，提前获得苹果的相关测试版程序，以及大量的开发资源。</code></p>
<p><img src="/images/2014/01/21.png" alt="iOS中利用GPUImage实现模糊效果"></p>
<p>下面我们先来看看本文的目录结构：</p>
<ul>
<li>开始</li>
<li>为什么要是用模糊效果<ul>
<li>深度引导</li>
<li>上下文</li>
<li>关注度</li>
</ul>
</li>
<li>添加静态的模糊效果<ul>
<li>创建截图Category</li>
<li>利用断点测试截屏图片 </li>
<li>显示截屏图片</li>
<li>设置contentsRect</li>
<li>重置模糊滤镜</li>
<li>对其背景图片</li>
</ul>
</li>
<li>实时模糊</li>
<li>线程中简洁的分支</li>
<li>一些潜在的实时模糊方案</li>
<li>一个折中的方法——对视频实时模糊<ul>
<li>利用GPUImage对视频进行模糊处理</li>
</ul>
</li>
<li>何去何从？</li>
</ul>
<h2 id="开始">开始</h2>
<p>首先先来<a href="http://cdn4.raywenderlich.com/wp-content/uploads/2013/12/Video-Blurring.zip" target="_blank" rel="external">这里</a>下载本文的starter工程，并将其解压出来。</p>
<p>用Xcode打开<code>Video Blurring.xcodeproj</code>，并将工程运行到设备中。此时看到程序的效果如下所示：</p>
<p><img src="/images/2014/01/22.png" alt=""></p>
<p>点击屏幕左上角的<code>菜单</code>(三条横纹)，可以看到界面中出现两个选项：录制视频和播放已有视频。</p>
<p>请注意，现在所有的用户界面都有一个灰色的背景，是不是感觉有点沉闷呢，本文我们就利用iOS 7中的模糊效果来替换掉这些沉闷的灰色背景。</p>
<h2 id="为什么要是用模糊效果">为什么要是用模糊效果</h2>
<p>除了外观看起来很棒以外，模糊效果还可以让程序给用户带来3个重要的概念：深度引导、上下文和关注度。</p>
<h3 id="深度引导">深度引导</h3>
<p>在用户界面上，模糊效果可以给用户提供一个深度引导效果，并且有利于用户对程序导航的理解。在之前的iOS版本中的深度引导效果是通过：三维斜面(three-dimensional bevels)和有关泽的按钮(反映出一个模拟的光源)，而在iOS 7中是通过模糊和视差(<a href="http://en.wikipedia.org/wiki/Parallax" target="_blank" rel="external">parallax</a>)来实现的。</p>
<p>这里说的视差效果，可以很明显的观察出来：在装有iOS 7的设备中，将设备从一侧倾斜至另一侧，会发现设备中的图标在移动(会独立于背景)。这样可以给用户做出一个提示：界面是由不同的层构成的，并且重要的界面元素是在最前面的——这也涉及到下面将要介绍的一个概念：上下文。</p>
<h3 id="上下文">上下文</h3>
<p>上下文可以让用户在程序内获得一种轴承的感觉。动画的过度效果就提供了一种非常优秀的上下文，当用户点击一个按钮时，在两个view之间利用动画效果来切换画面(而不是直接显示一个新的view)，可以让用户知道新的view是从哪里出现的，并且可以让用户很容易知道如何回到上一个view。</p>
<p>模糊效果可以将上一个view当做背景显示出来，尽管上一个view已经失去焦点了，不过可以给用户提供更多的上下文：刚刚是在哪里。通知中心就是一个非常棒的例子：当拉下通知中心时，我们可以在背景中看到原来的view(即使现在正在处于通知中心界面)。</p>
<h3 id="关注度">关注度</h3>
<p>让界面更加关注于某些选择项上，而移除不需要的内容，让用户可以更加快捷的进行导航。用户可以本能的忽略那些被模糊的界面元素，而将注意力集中到某些界面元素中。</p>
<p>通过本文，你将学到两种模糊类型的实现方法：静态模糊和动态模糊。静态模糊代表着快照的时间点，它并不能反映被模糊界面元素的变化。大多数情况下，使用静态模糊效果就足够了。相反，动态模糊则是对需要模糊的背景做出实时更新。</p>
<p>相信看到具体的效果才是最好的，下面我们就来看看模糊效果的具体实现吧！</p>
<h2 id="添加静态的模糊效果">添加静态的模糊效果</h2>
<p>创建一个静态模糊效果首先是将当前屏幕中的view转换为一幅图片。获得图片之后，只需要对图片做模糊处理就可以了。将view转换为一幅图片(截屏)苹果已经提供了一些非常棒的APIs了，并且在iOS 7中又有了新的方法可以让截屏更加快速。</p>
<p>这些新的方法属于<a href="https://developer.apple.com/library/ios/documentation/uikit/reference/uiview_class/uiview/uiview.html#//apple_ref/occ/instm/UIView/drawViewHierarchyInRect:afterScreenUpdates:" target="_blank" rel="external">截屏APIs</a>中的一部分，截屏APIs不仅可以对某个view截屏，还能把整个view层次截屏，如果你希望对某个view截屏，那么可以把view中的按钮、标签、开关等各种view也进行截屏。</p>
<p>此处我们将截屏的逻辑实现到<code>UIView</code>的一个category中。这样一来，我们就可以很方便快捷的将任意的view(以及view中的内容)转换为一个图片——也算是代码的重用吧。</p>
<h3 id="创建截图Category">创建截图Category</h3>
<p>打开<code>File/New/File...</code>，然后选择<code>iOS/Cocoa Touch/Objective-C category</code>，如下图所示：</p>
<p><img src="/images/2014/01/23.png" alt=""></p>
<p>将这个category命名为<code>Screenshot</code>，并将它的category选为<code>UIView</code>,如下图所示：</p>
<p><img src="/images/2014/01/24.png" alt=""></p>
<p>将下面这个方法声明到<code>UIView+Screenshot.h</code>中：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-(<span class="built_in">UIImage</span> *)convertViewToImage;</div></pre></td></tr></table></figure>

<p>接着将如下方法添加到<code>UIView+Screenshot.m</code>中：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">-(<span class="built_in">UIImage</span> *)convertViewToImage</div><div class="line">{</div><div class="line">    UIGraphicsBeginImageContext(<span class="keyword">self</span><span class="variable">.bounds</span><span class="variable">.size</span>);</div><div class="line">    [<span class="keyword">self</span> drawViewHierarchyInRect:<span class="keyword">self</span><span class="variable">.bounds</span> afterScreenUpdates:<span class="literal">YES</span>];</div><div class="line">    <span class="built_in">UIImage</span> *image = UIGraphicsGetImageFromCurrentImageContext();</div><div class="line">    UIGraphicsEndImageContext();</div><div class="line"> </div><div class="line">    <span class="keyword">return</span> image;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面的方法中，首先调用了<code>UIGraphicsBeginImageContext()</code>，最后调用的是<code>UIGraphicsEndImageContext()</code>，这两行代码可以理解为图形上下文的一个事物处理过程。一个上下文可以理解为不同的概念，例如屏幕，或者此处可以理解为一幅图片。这里的两行代码起到一个离屏画布的作用——可以将view绘制上去。</p>
<p><code>drawViewHierarchyInRect:afterScreenUpdates:</code>方法利用view层次结构并将其绘制到当前的上下文中。</p>
<p>最后，<code>UIGraphicsGetImageFromCurrentImageContext()</code>从图形上下文中获取刚刚生成的<code>UIImage</code>。</p>
<p>现在，我们已经完成了category的实现，接着我们只需要在使用到的地方将其import一下即可。</p>
<p>如下代码所示，将代码添加到<code>DropDownMenuController.m</code>顶部：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#import <span class="title">"UIView+Screenshot.h"</span></span></div></pre></td></tr></table></figure>

<p>同时，将如下方法添加到相同的文件中：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)updateBlur</div><div class="line">{</div><div class="line">    <span class="built_in">UIImage</span> *image = [<span class="keyword">self</span><span class="variable">.view</span><span class="variable">.superview</span> convertViewToImage];</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面的代码确保是对superview进行截屏，而不仅仅是当前的view。不这样做的话，截屏获得的图片只是menu本身。</p>
<h3 id="利用断点测试截屏图片">利用断点测试截屏图片</h3>
<p>为了测试截屏的效果，我们在<code>convertViewToImage</code>调用的下面一行添加一个断点。这样当命中断点时，程序会在断点中暂停执行，这样我们就可以看到截屏的图片，以此确保截屏代码的正确性:</p>
<p><img src="/images/2014/01/25.png" alt=""></p>
<p>在测试之前还有一件事情需要做：调用上面这个方法。</p>
<p>找到<code>show</code>方法，并在<code>addToParentViewController</code>下面直接调用一下<code>updateBlur</code>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)show {</div><div class="line">    [<span class="keyword">self</span> addToParentViewController];</div><div class="line"> </div><div class="line">    [<span class="keyword">self</span> updateBlur]; <span class="comment">// Add this line</span></div><div class="line"> </div><div class="line">    <span class="built_in">CGRect</span> deviceSize = [UIScreen mainScreen]<span class="variable">.bounds</span>;</div><div class="line"> </div><div class="line">    [<span class="built_in">UIView</span> animateWithDuration:<span class="number">0.25</span>f animations:^(<span class="keyword">void</span>){</div><div class="line">        _blurView<span class="variable">.frame</span> = CGRectMake(<span class="number">0</span>, <span class="number">0</span>, deviceSize<span class="variable">.size</span><span class="variable">.height</span>, MENUSIZE);</div><div class="line">        _backgroundView<span class="variable">.frame</span> = CGRectMake(<span class="number">0</span>, <span class="number">0</span>, _backgroundView<span class="variable">.frame</span><span class="variable">.size</span><span class="variable">.width</span>, MENUSIZE);</div><div class="line">    }];</div><div class="line">}</div></pre></td></tr></table></figure>

<p>编译并运行程序，点击菜单按钮，可以看到Xcode在断点出停止了，如下所示：</p>
<p><img src="/images/2014/01/26.png" alt=""></p>
<p>在debugger左下角hand pane中选择<code>image</code>，然后单击<code>快速查找图标</code>按钮，就可以预览刚刚的截屏啦：</p>
<p><img src="/images/2014/01/27.png" alt=""></p>
<p>如上图所示，正是我们所预期的。</p>
<h3 id="显示截屏图片">显示截屏图片</h3>
<p>将截取到的图片显示到菜单的背景中就是小菜一碟啦。</p>
<p>一般来说我们都会利用<code>UIImageView</code>来显示一幅图片，而由于我们要利用<code>GPUImage</code>来模糊图片，所以需要使用<code>GPUImageView</code>。</p>
<p>在这里的工程中，已经添加好了<code>GPUImage</code>框架，我们只需要将头文件import一下即可。</p>
<p>将下面的代码添加到<code>DropDownMenuController.m</code>顶部：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#import <span class="title">&lt;GPUImage/GPUImage.h&gt;</span></span></div></pre></td></tr></table></figure>

<p><code>注意：GPUImage被包含在一个框架中，所以在import语句中，需要利用尖括弧，而不是双引号</code>。</p>
<p>此时，有一个_blurView，类型为UIView——是菜单的灰色背景。将UIView修改为<code>GPUImageView</code>，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">DropDownMenuController</span> </span>{</div><div class="line">    GPUImageView *_blurView;</div><div class="line">    <span class="built_in">UIView</span> *_backgroundView;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>修改之后，Xcode会报一个warning：大意是你利用<code>UIView</code>进行实例化，而不是预期的<code>GPUImageView</code>。</p>
<p>可以通过下面的方法消除这个警告，在<code>viewDidLad</code>中修改做如下修改：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">_blurView = [[GPUImageView alloc] initWithFrame:CGRectMake(<span class="number">0</span>, <span class="number">0</span>, deviceSize<span class="variable">.size</span><span class="variable">.height</span>, <span class="number">0</span>)];</div></pre></td></tr></table></figure>

<p>紧随其后，将如下两行代码添加进去，并移除设置背景色的代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">_blurView<span class="variable">.clipsToBounds</span> = <span class="literal">YES</span>;</div><div class="line">_blurView<span class="variable">.layer</span><span class="variable">.contentsGravity</span> = kCAGravityTop;</div></pre></td></tr></table></figure>

<p><code>clipToBounds</code>属性设置为YES，把超出_blurView范围的子view隐藏起来，而<code>contentsGravity</code>确保图片出现在image view的顶部。</p>
<p>由于<code>_blurView</code>已经用于背景了，所以此处不需要额外设置了。</p>
<p>接着，我们还需要声明一个用于模糊效果的过滤器。</p>
<p>将如下代码添加到<code>DropDownMenuController.m:</code>文件的<code>@implementation</code>中：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GPUImageiOSBlurFilter *_blurFilter;</div></pre></td></tr></table></figure>

<p>找到之前添加的断点，右键单击，并选中<code>Delete Breakpoint</code>：</p>
<p><img src="/images/2014/01/28.png" alt=""></p>
<p>下面是非常重要的一步了——初始化模糊滤镜。将如下代码添加到<code>DropDownMenuController.m</code>中：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)updateBlur</div><div class="line">{</div><div class="line">    <span class="keyword">if</span>(_blurFilter == <span class="literal">nil</span>){</div><div class="line">        _blurFilter = [[GPUImageiOSBlurFilter alloc] init];</div><div class="line">         _blurFilter<span class="variable">.blurRadiusInPixels</span> = <span class="number">1.0</span>f;</div><div class="line"> </div><div class="line">    }</div><div class="line"> </div><div class="line">    <span class="built_in">UIImage</span> *image = [<span class="keyword">self</span><span class="variable">.view</span><span class="variable">.superview</span> convertViewToImage];</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>注意：上面将模糊半径设置为一个像素，这里暂时将这个值设置低一点，这样可以确保图片的正确定位，当一切ok之后，再增加模糊半径即可。</code></p>
<p>下面是时候将图片显示到<code>GPUImageView</code>中了。不过并不是简单的实例化一个<code>UIImage</code>，并将其添加到<code>GPUImageView</code>中。首先需创建一个<code>GPUImagePicture</code>。</p>
<p>将如下代码添加到<code>updateBlur</code>方法的底部：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GPUImagePicture *picture = [[GPUImagePicture alloc] initWithImage:image];</div></pre></td></tr></table></figure>

<p>至此，我们获得了一个图片，模糊滤镜和iamge view。</p>
<p>接着再将如下代码添加到<code>updateBlur</code>底部：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[picture addTarget:_blurFilter];</div><div class="line">[_blurFilter addTarget:_blurView];</div><div class="line"> </div><div class="line">[picture processImage];</div></pre></td></tr></table></figure>

<p>上面这几行代码，就像胶水一样，将所有的事情关联起来。将滤镜当做target添加到图片中，然后将image view当做滤镜的target。</p>
<p>上面代码对图片的处理全程发生在GPU上，也就是说当进行模糊计算和显示时，并不会影响到用户界面。当处理结束时，会把图片显示到image view上面。</p>
<p>编译并运行程序，点击菜单按钮，可以看到如下类似画面：</p>
<p><img src="/images/2014/01/29.png" alt=""></p>
<p>上面的图片看起来是不是有点奇怪？看到的图片被缩放到适配到菜单视图中了。要对此做出修正，我们需要指定图片的哪一部分需要显示在<code>GPUImageView</code>中——也就是处理截屏视图的上半部分。</p>
<h3 id="设置contentsRect">设置contentsRect</h3>
<p>按照如下代码所示修改<code>DropDownMenuController.m</code>文件中的<code>show</code>方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)show</div><div class="line">{</div><div class="line">    [<span class="keyword">self</span> addToParentViewController];</div><div class="line"> </div><div class="line">    [<span class="keyword">self</span> updateBlur];</div><div class="line"> </div><div class="line">    <span class="built_in">CGRect</span> deviceSize = [UIScreen mainScreen]<span class="variable">.bounds</span>;</div><div class="line"> </div><div class="line">    [<span class="built_in">UIView</span> animateWithDuration:<span class="number">0.25</span>f animations:^(<span class="keyword">void</span>){</div><div class="line">        _blurView<span class="variable">.frame</span> = CGRectMake(<span class="number">0.0</span>f, <span class="number">0.0</span>f, deviceSize<span class="variable">.size</span><span class="variable">.height</span>, MENUSIZE);</div><div class="line">        _backgroundView<span class="variable">.frame</span> = CGRectMake(<span class="number">0.0</span>f, <span class="number">0.0</span>f, _backgroundView<span class="variable">.frame</span><span class="variable">.size</span><span class="variable">.width</span>, MENUSIZE);</div><div class="line">        _blurView<span class="variable">.layer</span><span class="variable">.contentsRect</span> = CGRectMake(<span class="number">0.0</span>f, <span class="number">0.0</span>f, <span class="number">1.0</span>f, MENUSIZE / <span class="number">320.0</span>f); <span class="comment">// Add this line!</span></div><div class="line">    }];</div><div class="line">}</div></pre></td></tr></table></figure>

<p>通过指定<code>_blurView.layer.contentsRect</code>来定义一个矩形，在单元坐标空间(unit coordinate space)中，表示只使用layer content的一部分。</p>
<p>编译并运行程序，点击菜单按钮，会看到如下图所示效果：</p>
<p><img src="/images/2014/01/30.png" alt=""></p>
<p>虽然已经使用了图片的一部分，看起来还是不正确，这是因为它的缩放比例还不适合！此处还缺少对正确内容的缩放。</p>
<p>将下面这行代码添加到<code>show</code>方法中动画block的尾部：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">_blurView<span class="variable">.layer</span><span class="variable">.contentsScale</span> = (MENUSIZE / <span class="number">320.0</span>f) * <span class="number">2</span>;</div></pre></td></tr></table></figure>

<p><code>contentsScale</code>属性声明了layer在逻辑坐标空间(以点为单位)和物理坐标空间(以像素为单位)之间的映射关系。更高比例因子表示在渲染layer时，一个点代表着多个像素点。</p>
<p>编译并运行程序，点击菜单按钮，可以看到缩放比例已经正常了：</p>
<p><img src="/images/2014/01/31.png" alt=""></p>
<p>没错——看起来好多了！现在关闭程序，然后重新打开，ou~~发生了什么？如下图所示：</p>
<p><img src="/images/2014/01/32.png" alt=""></p>
<p>看起来这还是有点问题。如果在对view进行animation之前将contentScale设置回2.0，会解决half bar的问题。</p>
<p>将如下代码添加到<code>DropDownMenuController.m</code>中<code>show</code>方法里面的animation block上面：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">_blurView<span class="variable">.layer</span><span class="variable">.contentsScale</span> = <span class="number">2.0</span>f;</div></pre></td></tr></table></figure>

<p>编译并运行程序，然后点击菜单，接着关闭菜单，再打开菜单，此时菜单开起来如下所示：</p>
<p><img src="/images/2014/01/33.png" alt=""></p>
<p>现在半个尺寸的黑色box已经没有问题了——但是现在是全尺寸的黑色box！</p>
<h3 id="重置模糊滤镜">重置模糊滤镜</h3>
<p>上面问题产生的原因是由于进行了二次模糊计算。解决的方法是移除模糊滤镜中的所有target。如果不这样做的话，之后对滤镜的调用不会输出任何的内容——进而引起黑色box的问题。</p>
<p>按照如下代码更新一下<code>updateBlur</code>方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)updateBlur</div><div class="line">{</div><div class="line">    <span class="keyword">if</span>(_blurFilter == <span class="literal">nil</span>){</div><div class="line">        _blurFilter = [[GPUImageiOSBlurFilter alloc] init];</div><div class="line">        _blurFilter<span class="variable">.blurRadiusInPixels</span> = <span class="number">1.0</span>f;</div><div class="line">    }</div><div class="line"> </div><div class="line">    <span class="built_in">UIImage</span> *image = [<span class="keyword">self</span><span class="variable">.view</span><span class="variable">.superview</span> convertViewToImage];</div><div class="line"> </div><div class="line">    GPUImagePicture *picture = [[GPUImagePicture alloc] initWithImage:image];</div><div class="line">    [picture addTarget:_blurFilter];</div><div class="line">    [_blurFilter addTarget:_blurView];</div><div class="line"> </div><div class="line">    [picture processImageWithCompletionHandler:^{</div><div class="line">        [_blurFilter removeAllTargets];</div><div class="line">    }];</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面的代码用<code>processImageWithCompletionHandler:</code>替换了<code>processImage</code>方法。这个新的方法有一个completion block，当image 处理结束时，会运行这个block。一旦image处理结束，我们就可以安全的将滤镜中的target全部移除。</p>
<p>编译并运行程序，点击菜单，检查一下黑色box问题是不是已经解决掉了：</p>
<p><img src="/images/2014/01/34.png" alt=""></p>
<p>多次打开和关闭菜单，确保之前的那个bug已经解决掉啦！</p>
<p>现在仔细观察一下打开菜单的模糊效果——有些东西看起来不正确。为了更加明显的观察到问题，我们减慢动画的时间，让其慢慢的移动。</p>
<p>在<code>show</code>方法中，将animation bloc的持续时间修改为10.0f。</p>
<p>编译并运行程序，点击菜单，然后观察一下菜单出场的慢动作：</p>
<p><img src="/images/2014/01/35.png" alt=""></p>
<p>恩，现在可能你已经发现问题了。被模糊的图片从顶部往下滑动——而我们的本意是希望模糊效果从上往下滑(并不是图片本身)。</p>
<h3 id="对其背景图片">对其背景图片</h3>
<p>此处我们需要对静态模糊效果使用一些技巧。当出现菜单时，我们需要利用背景来将模糊效果对其。所以在这里我们不是对image view做移动处理，而是需要对image view做扩展处理，从0开始扩展至image view的全尺寸。这样就可以确保菜单打开时，图片依然保留在原位。</p>
<p>在<code>show</code>方法中，我们已经将菜单打开至全尺寸了，所以现在只需要将<code>contentRect</code>的高度设置为0即可(当image view首次创建并隐藏的时候)。</p>
<p>将下面的代码添加至<code>DropDownMenuController.m</code>文件的<code>viewDidLoad</code>方法中——在_blurView初始化的下方：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">_blurView<span class="variable">.layer</span><span class="variable">.contentsRect</span> = CGRectMake(<span class="number">0.0</span>f, <span class="number">0.0</span>f, <span class="number">1.0</span>f, <span class="number">0.0</span>f);</div></pre></td></tr></table></figure>

<p>同时，在相同的一个文件中，将下面的代码添加到animation block的尾部：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">_blurView<span class="variable">.layer</span><span class="variable">.contentsRect</span> = CGRectMake(<span class="number">0.0</span>f, <span class="number">0.0</span>f, <span class="number">1.0</span>f, <span class="number">0.0</span>f);</div></pre></td></tr></table></figure>

<p><code>contentRect</code>属性是可以动画方式设置的。因此在动画期间会rect会自动的插补上。</p>
<p>编译并运行程序。可以看到，问题已经解决：</p>
<p><img src="/images/2014/01/36.png" alt=""></p>
<p>这样看起来自然多了。现在我们已经有一个具有模糊背景的滑动菜单了。</p>
<p>现在是时候把动画所需时间调整一下了（为了更好的效果，其实之前设置的值是为了测试所用）：设置为0.25秒，接着在<code>updateBlur</code>方法中将<code>_blurFilter.blurRadiusInPixels</code>设置为<code>4.0f</code>。</p>
<p>编译并运行程序，多次打开菜单，看看效果如何：</p>
<p><img src="/images/2014/01/37.png" alt=""></p>
<h2 id="实时模糊">实时模糊</h2>
<p>实时模糊涉及到的技术具有一定的难度，有些难点需要解决才行。为了有效的进行实时模糊，我们需要不停(每秒60帧)的截屏、模糊计算和显示。使用<code>GPUImage</code>每秒中处理60张图片(模糊并显示图片)一点问题都没有。</p>
<p>真正棘手的问题是什么呢？如何实时的截取屏幕图片，信不信由你！</p>
<p>由于截取的屏幕是主用户界面，所有必须使用CPU的主线程来截屏，并将其转换为一幅图片。</p>
<p><code>提醒：如果事物每秒钟的变化速度在46帧以上，那么人眼就无法识别出来了。这对于开发者来说也是一种解脱——现代处理器在各帧之间可以完成更多的大量工作。</code></p>
<h2 id="线程中简洁的分支">线程中简洁的分支</h2>
<p>当运行程序时，会执行大量的指令列表。每一个指令列表都运行在各自的线程中，而我们又可以在多个线程中并发运行各自的指令列表。一个程序在主线程中开始运行，然后会根据需要，创建新的线程，并在后台执行线程。如果之前你并没有管理过多线程，你可能在写程序的时候总是在主线程中执行指令。</p>
<p>主线程主要处理与用户的交互，以及界面的更新。确保主线程的响应时间是非常关键的。如果在主线程上做了太多的任务，你会明显的感觉到主界面响应迟钝。</p>
<p>如果你曾经使用过Twitter货Facebook，并滚动操作过它里面的内容，你可能已经感觉到后台线程在执行操作了——在滚动的过程中，并不是所有的个人图片立即显示出来，滚动过程中，程序会启动后台线程来获取图片，当图片获取成功之后，再显示到屏幕中。</p>
<p>如果不使用后台线程，那么table view的滚动过程中，如果在主线程上去获取个人图片，会感觉到table view被冻结住了。由于图片的获取需要一些时间，所以最好将这样耗时的操作让后台线程来做，这样就能对用户界面做平滑的操作和响应了。</p>
<p>那么对本文的程序有什么影响呢？之间介绍了，<code>UIView</code>的截屏APIs操作必须在主线程中运行。这就意味着每次截屏时，整个用户界面都会被冻结中。</p>
<p>对于静态模糊效果时，由于这个截屏操作很快，你不会感觉到界面的冻结。并且只需要截屏一次。然而在实时模糊效果中需要每秒中截屏60次。如果在主线程中做这样频繁的截屏操作，那么animation和transition会变得非常的迟钝。</p>
<p>更糟糕的时，如果用户界面复杂度增加，那么在截屏过程中就需要消耗更多的时间，那么就会导致整个程序无法使用了！</p>
<p>那么怎么办呢！</p>
<h2 id="一些潜在的实时模糊方案">一些潜在的实时模糊方案</h2>
<p>这里有一个关于实时模糊方案：源代码开源的<a href="https://github.com/nicklockwood/FXBlurView" target="_blank" rel="external">live blur libraries</a>，它通过降低截屏的速度来实现实时模糊效果，并不是使用每秒截屏60次，可能是20、30或者40次。即使看起来没有多大区别，但是你的眼睛还是能发现一定的迟钝——模糊效果并没有跟程序的其它部分同步起来——这样一来，界面看起会没有模糊效果更加的糟糕。</p>
<p>实际上苹果在它们自己的一些程序中处理实时模糊并不存在类似的问题——但是苹果并没有公开相关的API。在iOS 7中<code>UIView</code>的截屏方法，相比于旧方法，性能有了很大的提升，但还是不能满足实时模糊的需求。</p>
<p>一些开发者利用<code>UIToolbar</code>的模糊效果来做一些不好的操作。没错，这是有效果的，但是强烈建议不要在程序中使用它们。虽然这不是私有API，但是这并不算是一种可行的方法，苹果也可能会<a href="https://github.com/JagCesar/iOS-blur/issues/25" target="_blank" rel="external">reject</a>你的程序。也就是说在，在之后的iOS 7版本中，并不能保证还能正常使用。</p>
<p>苹果可以在任何时候对<code>UIToolBar</code>做出修改，或许你的程序就有问题了。在iOS 7.0.3更新中，苹果的修改已经影响到UIToolbar和UINavigationBar了，有些开发者也因此报告出利用相关模糊效果已经失效了！所以最好不要陷入这样潜在的陷阱里面！</p>
<h2 id="一个折中的方法——对视频实时模糊">一个折中的方法——对视频实时模糊</h2>
<p>OK，此时你可能在想，要想在程序中做到实时模糊是不可能的了。那么还有什么方法可以突破限制，做到实时模糊效果呢？</p>
<p>在许多场景中，静态模糊是可以接受的。上一节中，我们对view做适当的修改，让用户看起来是对背景图做的实际模糊处理。当然，这对于静止不动的背景是合适的，并且还可以在模糊背景上实现一些不错的效果。</p>
<p>我们可以做一些实验，看看能不能找到一些效果来实现之前无法做到的实时模糊效果呢？</p>
<p>有一个方法可以试试：对实时视频做模糊处理，虽然截屏是一个非常大的瓶颈，但是<code>GPUImage</code>非常的强大，它能够对视频进行模糊(无论是来自摄像头的视频或者已经录制好的视频，都没问题)。</p>
<h3 id="利用GPUImage对视频进行模糊处理">利用GPUImage对视频进行模糊处理</h3>
<p>利用<code>GPUImage</code>对视频的模糊处理与图片的模糊处理类似。针对图片，我们实例化一个<code>GPUImagePicture</code>，然后将其发送给<code>GPUImageiOSBlurFilter</code>，接着再将其发送给<code>GPUImageView</code>。</p>
<p>类似的方法，对于视频，我们使用<code>GPUImageVideoCamera</code>或<code>GPUImageMovie</code>，将后将其发送给<code>GPUImageiOSBlurFilter</code>，接着再将其发送给一个<code>GPUImageView</code>。<code>GPUImageVideoCamera</code>用于设备中的实时摄像头，而<code>GPUImageMovie</code>用于已经录制好的视频。</p>
<p>在我们的starter工程中，已经实例化并配置好了<code>GPUImageVideoCamera</code>。现在的任务是将播放和录制按钮的灰色背景替换为视频的实时滤镜效果。</p>
<p>首先是将此处提供的灰色背景实例<code>UIView</code>替换为<code>GPUImageView</code>。完成之后，我们需要调整每个view的<code>contentRect</code>(基于view的frame)。</p>
<p>这听起来对每个view都需要做大量的工作。为了让任务变得简单，我们创建一个<code>GPUImageView</code>的子类，并把自定义的代码放进去，以便重用。</p>
<p>打开<code>File/New/File…</code>，然后选择<code>iOS/Cocoa Touch/Objective-C class</code>，如下所示：</p>
<p><img src="/images/2014/01/38.png" alt=""></p>
<p>将类命名为<code>BlurView</code>，继承自<code>GPUImageView</code>，如下图所示：</p>
<p><img src="/images/2014/01/39.png" alt=""></p>
<p>打开<code>ViewController.m</code>文件，将下面的import添加到文件顶部：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#import <span class="title">"BlurView.h"</span></span></div></pre></td></tr></table></figure>

<p>还是在<code>ViewController.m</code>中，在<code>@implementation</code>中找到<code>_recordView</code>和<code>_controlView</code>的声明，将其修改为<code>BlurView</code>类型，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">BlurView *_recordView; <span class="comment">//Update this!</span></div><div class="line"><span class="built_in">UIButton</span> *_recordButton;</div><div class="line"><span class="built_in">BOOL</span> _recording;</div><div class="line"> </div><div class="line">BlurView *_controlView; <span class="comment">//Update this too!</span></div><div class="line"><span class="built_in">UIButton</span> *_controlButton;</div><div class="line"><span class="built_in">BOOL</span> _playing;</div></pre></td></tr></table></figure>

<p>然后按照如下代码修改<code>viewDidLoad</code>方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">_recordView = [[BlurView alloc] initWithFrame:</div><div class="line">                CGRectMake(<span class="keyword">self</span><span class="variable">.view</span><span class="variable">.frame</span><span class="variable">.size</span><span class="variable">.height</span>/<span class="number">2</span> - <span class="number">50</span>, <span class="number">250</span>, <span class="number">110</span>, <span class="number">60</span>)]; <span class="comment">//Update this!</span></div><div class="line"><span class="comment">//_recordView.backgroundColor = [UIColor grayColor]; //Delete this!</span></div><div class="line"> </div><div class="line">_recordButton = [<span class="built_in">UIButton</span> buttonWithType:UIButtonTypeCustom];</div><div class="line">_recordButton<span class="variable">.frame</span> = CGRectMake(<span class="number">5</span>, <span class="number">5</span>, <span class="number">100</span>, <span class="number">50</span>);</div><div class="line">[_recordButton setTitle:<span class="string">@"Record"</span> forState:UIControlStateNormal];</div><div class="line">[_recordButton setTitleColor:[<span class="built_in">UIColor</span> redColor] forState:UIControlStateNormal];</div><div class="line">[_recordButton setImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"RecordDot.png"</span>] forState:UIControlStateNormal] ;</div><div class="line">[_recordButton addTarget:<span class="keyword">self</span> </div><div class="line">                  action:<span class="keyword">@selector</span>(recordVideo) </div><div class="line">        forControlEvents:UIControlEventTouchUpInside];</div><div class="line"> </div><div class="line">[_recordView addSubview:_recordButton];</div><div class="line">_recording = <span class="literal">NO</span>;</div><div class="line"> </div><div class="line">_recordView<span class="variable">.hidden</span> = <span class="literal">YES</span>;</div><div class="line">[<span class="keyword">self</span><span class="variable">.view</span> addSubview:_recordView];</div><div class="line"> </div><div class="line"> </div><div class="line">_controlView = [[BlurView alloc] initWithFrame:</div><div class="line">                 CGRectMake(<span class="keyword">self</span><span class="variable">.view</span><span class="variable">.frame</span><span class="variable">.size</span><span class="variable">.height</span>/<span class="number">2</span> - <span class="number">40</span>, <span class="number">230</span>, <span class="number">80</span>, <span class="number">80</span>)]; <span class="comment">//Update this!</span></div><div class="line"><span class="comment">//_controlView.backgroundColor = [UIColor grayColor]; //Delete this!</span></div></pre></td></tr></table></figure>

<p>接着，需要创建模糊图片，将其显示到上面构建的image view中。回到<code>@implementation</code>中，将下面的两个声明添加进去：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">GPUImageiOSBlurFilter *_blurFilter;</div><div class="line">GPUImageBuffer *_videoBuffer;</div></pre></td></tr></table></figure>

<p>现在你已经知道<code>GPUImageiOSBlurFilter</code>的作用了，那么<code>GPUImageBuffer</code>的作用是什么呢？它的任务是获取视频的输出，并获取每一帧，这样我们就可以方便的对其做模糊处理。一个额外的好处就是它可以提升程序的性能！</p>
<p>一般来说，视频输出的内容会通过模糊滤镜处理，然后发送到背景视图中(被显示出来)。不过，在这里使用buffer的话，发送到buffer的视频输出内容，会被分为背景视图和模糊滤镜。这样可以对视频的输出显示做到平滑处理。</p>
<p>将下面的代码添加到<code>viewDidLoad</code>方法的顶部(在super调用的后面)：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">_blurFilter = [[GPUImageiOSBlurFilter alloc] init];</div><div class="line"> </div><div class="line">_videoBuffer = [[GPUImageBuffer alloc] init];</div><div class="line">[_videoBuffer setBufferSize:<span class="number">1</span>];</div></pre></td></tr></table></figure>

<p>还是在同一个文件中，将如下高亮显示的语句添加到<code>useLiveCamera</code>方法中：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)useLiveCamera</div><div class="line">{</div><div class="line">    <span class="keyword">if</span> (![UIImagePickerController isSourceTypeAvailable: UIImagePickerControllerSourceTypeCamera]) {</div><div class="line">        UIAlertView *alert = [[UIAlertView alloc] initWithTitle:<span class="string">@"No camera detected"</span> </div><div class="line">                                                        message:<span class="string">@"The current device has no camera"</span> </div><div class="line">                                                       delegate:<span class="keyword">self</span> </div><div class="line">                                              cancelButtonTitle:<span class="string">@"Ok"</span> </div><div class="line">                                              otherButtonTitles:<span class="literal">nil</span>];</div><div class="line">        [alert show];</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    }</div><div class="line"> </div><div class="line">    _liveVideo = [[GPUImageVideoCamera alloc] initWithSessionPreset:AVCaptureSessionPreset1280x720</div><div class="line">                                                     cameraPosition:AVCaptureDevicePositionBack];</div><div class="line">    _liveVideo<span class="variable">.outputImageOrientation</span> = UIInterfaceOrientationLandscapeLeft;</div><div class="line"> </div><div class="line">    [_liveVideo addTarget:_videoBuffer];           <span class="comment">//Update this</span></div><div class="line">    [_videoBuffer addTarget:_backgroundImageView]; <span class="comment">//Add this</span></div><div class="line">    [_videoBuffer addTarget:_blurFilter];          <span class="comment">//And this</span></div><div class="line">    [_blurFilter addTarget:_recordView];           <span class="comment">//And finally this</span></div><div class="line"> </div><div class="line">    [_liveVideo startCameraCapture];</div><div class="line"> </div><div class="line">    _recordView<span class="variable">.hidden</span> = <span class="literal">NO</span>;</div><div class="line">    _controlView<span class="variable">.hidden</span> = <span class="literal">YES</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面的模糊背景是用于录制按钮的。对于播放按钮也要做类似的处理。</p>
<p>将下面的代码添加到<code>loadVideoWithURL:</code>方法中(在<code>_recordedVideo.playAtActualSpeed = YES;</code>之后)：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[_recordedVideo addTarget:_videoBuffer]; </div><div class="line">[_videoBuffer addTarget:_backgroundImageView];</div><div class="line">[_videoBuffer addTarget:_blurFilter];</div><div class="line">[_blurFilter addTarget:_controlView];</div></pre></td></tr></table></figure>

<p>编译并运行程序，打开录制操作，看看情况如何：</p>
<p><img src="/images/2014/01/40.png" alt=""></p>
<p>好消息是看起来基本正常！坏消息是整个屏幕被缩放到录制按钮中去了。这个问题跟之前遇到的类似。我们需要给<code>BlurView</code>这是适当的<code>contentRect</code>。</p>
<p>打开<code>BlurView.m</code>，用下面的代码替换掉<code>initWithFrame:</code>方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)initWithFrame:(<span class="built_in">CGRect</span>)frame</div><div class="line">{</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithFrame:frame];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) {</div><div class="line">        <span class="built_in">CGRect</span> deviceSize = [UIScreen mainScreen]<span class="variable">.bounds</span>;</div><div class="line">        <span class="keyword">self</span><span class="variable">.layer</span><span class="variable">.contentsRect</span> = CGRectMake(frame<span class="variable">.origin</span><span class="variable">.x</span>/deviceSize<span class="variable">.size</span><span class="variable">.height</span>, </div><div class="line">                                             frame<span class="variable">.origin</span><span class="variable">.y</span>/deviceSize<span class="variable">.size</span><span class="variable">.width</span>, </div><div class="line">                                             frame<span class="variable">.size</span><span class="variable">.width</span>/deviceSize<span class="variable">.size</span><span class="variable">.height</span>, </div><div class="line">                                             frame<span class="variable">.size</span><span class="variable">.height</span>/deviceSize<span class="variable">.size</span><span class="variable">.width</span>);</div><div class="line">        <span class="keyword">self</span><span class="variable">.fillMode</span> = kGPUImageFillModeStretch;</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>contentRect</code>的每个参数必须在<code>0.0f</code>和<code>1.0f</code>之间。在这里只需要利用view的位置除以屏幕的size，得到的值即可。</p>
<p>编译并运行程序，看看效果如何：</p>
<p><img src="/images/2014/01/41.png" alt=""></p>
<p>恭喜！至此已经完成了静态模糊和实时视频模糊的实现。现在你已经完全可以在程序中添加iOS 7的模糊效果啦！</p>
<h2 id="何去何从？">何去何从？</h2>
<p>可以在<a href="http://cdn3.raywenderlich.com/wp-content/uploads/2014/01/Video-Blurring-Final1.zip" target="_blank" rel="external">这里</a>下载到完整的工程。</p>
<p>本文不仅指导你在程序中使用iOS 7的模糊效果，还介绍了如何使用<code>GPUImage</code>框架，这个框架也是我非常希望你能看到的东西。重要的是，本文指出了为什么要使用模糊，什么时候使用模糊效果是合适的，这在iOS 7的新设计语言中是一个关键的概念。当然也希望在未来的版本中，苹果能够将相关APIs提供给开发者使用，不过在那之前，<code>GPUImage</code>是一个不错的替代品。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="/images/2014/01/42.png" alt=""></p>
]]>
    
    </summary>
    
      <category term="iOS探索" scheme="http://beyondvincent.com/categories/iOS%E6%8E%A2%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[对NSArray中自定义的对象进行排序]]></title>
    <link href="http://beyondvincent.com/2014/01/26/2014-01-26-how-to-sort-nsarray-with-custom-objects/"/>
    <id>http://beyondvincent.com/2014/01/26/2014-01-26-how-to-sort-nsarray-with-custom-objects/</id>
    <published>2014-01-26T08:00:00.000Z</published>
    <updated>2014-12-31T19:05:45.000Z</updated>
    <content type="html"><![CDATA[<p><img src="/images/2014/01/20.png" alt=""></p>
<a id="more"></a>

<p>本文译自<a href="http://ios-blog.co.uk/tutorials/how-to-sort-nsarray-with-custom-objects/" target="_blank" rel="external">How to sort NSArray with custom objects</a>。</p>
<p>我们开发的每个程序都会使用到一些数据，而这些数据一般被封装在一个自定义的类中。例如一个音乐程序可能会有一个Song类，聊天程序则又一个Friend类，点菜程序会有一个Recipe类等。有时候我们希望在程序中显示的列表数据是按照一定顺序进行排列的，本文我们就来看看在iOS中有哪些方法可以对NSArray中的对象进行排序。下面是目录：</p>
<ul>
<li>小引</li>
<li>使用NSComparator进行排序</li>
<li>使用NSDescriptor进行排序</li>
<li>使用selector进行排序</li>
</ul>
<h3 id="小引">小引</h3>
<p>我们将要排序的对象是一个Persion类，如下定义：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></div><div class="line"> </div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *surname;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSDate</span> *dateOfBirth;</div><div class="line"> </div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>

<p>而数组中包含如下内容：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Smith John <span class="number">03</span>/<span class="number">01</span>/<span class="number">1984</span></div><div class="line">Andersen Jane <span class="number">16</span>/<span class="number">03</span>/<span class="number">1979</span></div><div class="line">Clark Anne <span class="number">13</span>/<span class="number">09</span>/<span class="number">1995</span></div><div class="line">Smith David <span class="number">19</span>/<span class="number">07</span>/<span class="number">1981</span></div><div class="line">Johnson Rose <span class="number">22</span>/<span class="number">02</span>/<span class="number">1989</span></div></pre></td></tr></table></figure>

<h3 id="使用NSComparator进行排序">使用NSComparator进行排序</h3>
<p>comparator实际上是用一个block对象作比较操作。它的定义如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> NSComparisonResult (^NSComparator)(<span class="keyword">id</span> obj1, <span class="keyword">id</span> obj2);</div></pre></td></tr></table></figure>

<p>上面的参数(obj1、obj2)就是我们将要做比较的对象。block返回的结果为NSComparisonResult类型来表示两个对象的顺序。</p>
<p>要对整个数组做排序，则需要使用NSArray的<code>sortArrayUsingComparator:</code>方法，如下代码所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *sortedArray = [<span class="keyword">self</span><span class="variable">.persons</span> sortedArrayUsingComparator:^NSComparisonResult(Person *p1, Person *p2){</div><div class="line"> </div><div class="line">    <span class="keyword">return</span> [p1<span class="variable">.surname</span> compare:p2<span class="variable">.surname</span>];</div><div class="line"> </div><div class="line">}];</div></pre></td></tr></table></figure>

<p>最终排序的结果如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Andersen Jane</div><div class="line">Clark Anne</div><div class="line">Johnson Rose</div><div class="line">Smith John</div><div class="line">Smith David</div></pre></td></tr></table></figure>

<h3 id="使用NSDescriptor进行排序">使用NSDescriptor进行排序</h3>
<p>Sort descriptor不仅可以用来对数组进行排序，还能指定element在table view中的排序，以及Core Data中对fetch request返回的数据做排序处理。通过sort descriptor可以很方便的对数组进行多个key的排序。下面来看看如何对我们的数组做surname排序，然后在进行name排序：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NSSortDescriptor *firstDescriptor = [[NSSortDescriptor alloc] initWithKey:<span class="string">@"surname"</span> ascending:<span class="literal">YES</span>];</div><div class="line">NSSortDescriptor *secondDescriptor = [[NSSortDescriptor alloc] initWithKey:<span class="string">@"name"</span> ascending:<span class="literal">YES</span>];</div><div class="line"> </div><div class="line"><span class="built_in">NSArray</span> *sortDescriptors = [<span class="built_in">NSArray</span> arrayWithObjects:firstDescriptor, secondDescriptor, <span class="literal">nil</span>];</div><div class="line"> </div><div class="line"><span class="built_in">NSArray</span> *sortedArray = [<span class="keyword">self</span><span class="variable">.persons</span> sortedArrayUsingDescriptors:sortDescriptors];</div></pre></td></tr></table></figure>

<p>上面代码的排序结果如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Andersen Jane</div><div class="line">Clark Anne</div><div class="line">Johnson Rose</div><div class="line">Smith David</div><div class="line">Smith John</div></pre></td></tr></table></figure>

<h3 id="使用selector进行排序">使用selector进行排序</h3>
<p>当面，我们也可以定义自己的方法进行两个对象做比较，并将该方法用于数组排序。comparator消息会被发送到数值中的每个对象中，并携带数组中另外的一个对象当做参数。自定义的的方法的返回结果是这样的：如果本身对象小于参数中的对象，就返回<code>NSOrederedAscending</code>，相反，则返回<code>NSOrderedDescending</code>，如果相等，那么返回<code>NSOrderedSame</code>。如下代码所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (NSComparisonResult)compare:(Person *)otherPerson {</div><div class="line"> </div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span><span class="variable">.dateOfBirth</span> compare:otherPerson<span class="variable">.dateOfBirth</span>];</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个方法定义在Person类中，用来对person的生日进行排序。</p>
<p>上面所介绍的这些方法都是为了完成相同的事情：对数组做排序处理，你可能在想改选择使用哪个呢？当需要通过多个key进行排序，那么最简单的方法就是使用sort descriptor。如果比较方法很复杂的话，建议在使用外面自己的selector。Block是再iOS 4之后引入的一个强大功能，用block作比较，可以不必使用任何的变量就能完成一个简单的比较方法，当然，你也可以定义一个复杂的block，来替换selector。</p>
<p>最后，其实这里并没有标准答案，你可以跟着自己的感觉走:]</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="/images/2014/01/20.png" alt=""></p>
]]>
    
    </summary>
    
      <category term="iOS探索" scheme="http://beyondvincent.com/categories/iOS%E6%8E%A2%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Objective-C中的Literals]]></title>
    <link href="http://beyondvincent.com/2014/01/23/2014-01-23-guided-tour-through-objective-c-literals/"/>
    <id>http://beyondvincent.com/2014/01/23/2014-01-23-guided-tour-through-objective-c-literals/</id>
    <published>2014-01-23T07:30:00.000Z</published>
    <updated>2014-12-31T19:05:45.000Z</updated>
    <content type="html"><![CDATA[<p><img src="/images/2014/01/19.png" alt=""></p>
<a id="more"></a>

<p>本文译自<a href="http://www.thinkandbuild.it/guided-tour-through-objective-c-literals/" target="_blank" rel="external">Guided tour through Objective-C Literals</a>。大家要是有什么问题，可以直接在<a href="https://twitter.com/bitwaker" target="_blank" rel="external">twitter</a>上联系原作者，当然也可以在最后的评论中回复我。</p>
<p>苹果在2012年就已经把Literals加入到LLVM中，利用Literals，不仅可以方便快捷的创建某些特定数据类型，还可以简化代码量，加强代码的可读性。</p>
<p>下面先来看看目录：</p>
<ol>
<li>NSNumber</li>
<li>NSArray</li>
<li>NSDictionary</li>
<li>Expressions</li>
</ol>
<p>下面我们就让代码来说话吧。</p>
<h3 id="1-_NSNumber">1. NSNumber</h3>
<p>曾经你是否一直这样来实例化<code>NSNumber</code>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSNumber</span> *integer = [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">19</span>];</div></pre></td></tr></table></figure>

<p>是不是感觉比较麻烦，现在好了，通过Literal，只需要如下一行简洁的代码即可：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSNumber</span> *integer = @<span class="number">19</span></div></pre></td></tr></table></figure>

<p>在上面的代码中，使用了<code>@</code>符号，这跟创建NSString一样(只是不用双引号吧了)，这样一来，就非常容易记住和使用啦。</p>
<p>不仅如此，我们还可以利用C语言中的后缀风格来定义NSNumber，如下代码所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSNumber</span> *unsignedInteger = @<span class="number">19</span>U;   <span class="comment">//Unsigned Integer</span></div><div class="line"><span class="built_in">NSNumber</span> *longInteger = @<span class="number">19</span>L;       <span class="comment">//Long Integer</span></div><div class="line"><span class="built_in">NSNumber</span> *floatNumber = @<span class="number">19.5493</span>F;  <span class="comment">//Float </span></div><div class="line"> </div><div class="line"><span class="built_in">NSNumber</span> *boolean = @YES; <span class="comment">//        //BOOL</span></div></pre></td></tr></table></figure>

<h3 id="2-_NSArray">2. NSArray</h3>
<p>有些编程语言创建数组是非常简单的，例如PHP。但是在引入Literal之前，Objective-C中创建数组的语法确不简单。如下代码所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *array = [<span class="built_in">NSArray</span> arrayWithObjects: [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">10</span>],</div><div class="line">                                            <span class="string">@"A String!"</span>,</div><div class="line">                                            [<span class="built_in">NSNumber</span> numberWithFloat:<span class="number">10.654</span>F],</div><div class="line">                                             <span class="literal">nil</span>];</div></pre></td></tr></table></figure>

<p>上面代码中不仅初始化对象复杂，还需要额外添加一个nil。但是要用Literal，看起来完全不一样了：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *array_l = @[@<span class="number">10</span>, <span class="string">@"A string"</span>, @<span class="number">10.645</span>F];</div></pre></td></tr></table></figure>

<p>如上所示，利用Literal，可以通过<code>@[]</code>轻松的搞定数组初始化，并且省掉最后的<code>nil</code>。实际上编译器会把上面的代码替换为<code>[NSArray arrayWithObjects:count:]</code>。</p>
<p>在Literal之前，访问数组中的对象需要使用一个类似这样的方法<code>objectAtIndex</code>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = [array objectAtIndex:<span class="number">0</span>];</div></pre></td></tr></table></figure>

<p>而来到Literal的世界中，可以使用一对方括弧<code>[]</code>加对象对应的索引就可以访问到了：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = array[<span class="number">0</span>];</div></pre></td></tr></table></figure>

<p>通过上面的语法，我们可以按照下面的方法来修改可变数组中的值：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSMutableArray</span> *mutableArray = [<span class="built_in">NSMutableArray</span> arrayWithObject:@[@<span class="number">11</span>,@<span class="number">76</span>]];</div><div class="line">mutableArray[<span class="number">0</span>] = @<span class="number">51</span>;</div></pre></td></tr></table></figure>

<h3 id="3-_NSDictionary">3. NSDictionary</h3>
<p>在Literal引入之前，NSDictionary对象的实例化跟NSArray类似，看起来也很长，并且在最后需要<code>nil</code>，如下代码所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSDictionary</span> *dict = [<span class="built_in">NSDictionary</span> dictionaryWithObjects:[<span class="built_in">NSArray</span> arrayWithObjects: [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">10</span>],</div><div class="line">                                                                                    [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">20</span>],</div><div class="line">                                                                                    [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">30</span>],</div><div class="line">                                                                                    <span class="literal">nil</span>]</div><div class="line">                                                 forKeys:[<span class="built_in">NSArray</span> arrayWithObjects: <span class="string">@"first"</span>,</div><div class="line">                                                                                    <span class="string">@"second"</span>,</div><div class="line">                                                                                    <span class="string">@"third"</span>,</div><div class="line">                                                                                    <span class="literal">nil</span>]];</div></pre></td></tr></table></figure>

<p>上面的代码看起来着实有点过头了。如果要用Literal的话，就简洁明了多了：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSDictionary</span> *dicts = @{<span class="string">@"first"</span>:@<span class="number">10</span>, <span class="string">@"second"</span>:@<span class="number">20</span>, <span class="string">@"third"</span>:@<span class="number">30</span>};</div></pre></td></tr></table></figure>

<p>在上面NSDictionary实例化过程中，通过Literal，除了可以定义NSNumber和NSArray之外，还可以以可读的方式一一放置key和对应的值。相信这种方法大家都会喜欢。</p>
<p>从上面的介绍，你应该会喜欢上Literal，它确实可以让我们的代码更加容易读懂，并且不容易出错！！！</p>
<p>另外，我们还可以通过下面这样的方式访问字典中key对应的内容：(感谢<a href="http://weibo.com/u/2135198615" target="_blank" rel="external">@谌启亮</a>在评论中的提醒)</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *firstValue = dicts[<span class="string">@"first"</span>]</div></pre></td></tr></table></figure>

<p>// 注意：下面这一点内容我摘自<a href="http://clang.llvm.org/docs/ObjectiveCLiterals.html" target="_blank" rel="external">Objective-C-Literals-Boxed Expressions</a></p>
<h3 id="4-_Expressions">4. Expressions</h3>
<p>Objective-C提供了一种新的语法对C表达式进行包装：<code>@( &lt;expression&gt; )</code></p>
<p>它支持标量表达式(numeric, enumerated, BOOL)，以及C字符串指针类型：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// numbers.</span></div><div class="line"><span class="built_in">NSNumber</span> *smallestInt = @(-INT_MAX - <span class="number">1</span>);  <span class="comment">// [NSNumber numberWithInt:(-INT_MAX - 1)]</span></div><div class="line"><span class="built_in">NSNumber</span> *piOverTwo = @(M_PI / <span class="number">2</span>);        <span class="comment">// [NSNumber numberWithDouble:(M_PI / 2)]</span></div><div class="line"></div><div class="line"><span class="comment">// enumerated types.</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> { Red, Green, Blue } Color;</div><div class="line"><span class="built_in">NSNumber</span> *favoriteColor = @(Green);       <span class="comment">// [NSNumber numberWithInt:((int)Green)]</span></div><div class="line"></div><div class="line"><span class="comment">// strings.</span></div><div class="line"><span class="built_in">NSString</span> *path = @(getenv(<span class="string">"PATH"</span>));       <span class="comment">// [NSString stringWithUTF8String:(getenv("PATH"))]</span></div><div class="line"><span class="built_in">NSArray</span> *pathComponents = [path componentsSeparatedByString:<span class="string">@":"</span>];</div></pre></td></tr></table></figure>

<p>关于Literals的更多详细内容可以参考：<a href="http://clang.llvm.org/docs/ObjectiveCLiterals.html" target="_blank" rel="external">Objective-C-Literals</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="/images/2014/01/19.png" alt=""></p>
]]>
    
    </summary>
    
      <category term="iOS探索" scheme="http://beyondvincent.com/categories/iOS%E6%8E%A2%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何自定义iOS中的控件]]></title>
    <link href="http://beyondvincent.com/2014/01/20/2014-01-20-how-to-build-a-custom-control-in-ios/"/>
    <id>http://beyondvincent.com/2014/01/20/2014-01-20-how-to-build-a-custom-control-in-ios/</id>
    <published>2014-01-20T09:00:00.000Z</published>
    <updated>2014-12-31T19:05:45.000Z</updated>
    <content type="html"><![CDATA[<p><img src="/images/2014/01/18.png" alt=""></p>
<a id="more"></a>

<p>本文译自<a href="http://www.thinkandbuild.it/how-to-build-a-custom-control-in-ios/" target="_blank" rel="external">How to build a custom control in iOS</a>。大家要是有什么问题，可以直接在<a href="https://twitter.com/bitwaker" target="_blank" rel="external">twitter</a>上联系原作者，当然也可以在最后的评论中回复我。</p>
<p>下面先来看看目录：</p>
<ol>
<li>子类化UIControl<ul>
<li>绘制用户界面<ul>
<li>绘制背景</li>
<li>绘制用户的可操作区域</li>
<li>绘制手柄</li>
</ul>
</li>
<li>跟踪用户的操作<ul>
<li>开始跟踪</li>
<li>持续跟踪</li>
<li>结束跟踪</li>
</ul>
</li>
<li>Target-Action模式</li>
</ul>
</li>
<li>如何使用自定义控件</li>
<li>总结</li>
<li>代码下载</li>
</ol>
<p>在开发过程中，有时候UIKit的标准控件并不能满足我们的需求，例如你需要一个控件能支持用户方便的选择0-360°之间的一个角度值，此时就需要根据自己的需求自定义控件了。</p>
<p>对于选择角度值的控件可以这样实现：创建一个圆形的滑块，用户通过拖动手柄操作就能选择角度值。实际上这样的控件在别的一些平台中你可能看到过，但是在UIKit中并没有。</p>
<p>本文就实现一个选择角度值的控件来介绍控件的自定义。下面先来看看到底要做成什么样子：</p>
<p><img src="/images/2014/01/12.png" alt=""></p>
<h3 id="1-_子类化UIControl">1. 子类化UIControl</h3>
<p><code>UIControl</code>是UIView的子类，它又是所有UIKit控件的父类(例如UIButton、UISlider和UISwitch等)。</p>
<p>UIControl的主要作用是创建相应的逻辑将action分发到对应的target，另外90%的情况下，它会根据自身的状态(例如Highlighted, Selected和Disabled等)来绘制用户界面。</p>
<p>通过UIControl，我们主要管理3个重要的任务：</p>
<ul>
<li>绘制用户界面</li>
<li>跟踪用户的操作</li>
<li>Target-Action模式</li>
</ul>
<p>在本文的圆形滑块中，我们要做如下一些事情：</p>
<p>定制一个用户界面(圆形滑块本身)，通过该界面用户可以通过手柄进行界面交互。用户的交互操作会被转换为控件target对应的action(控件将滑块按钮的frame origin转换为0-360之间的一个值，并用于target/action上)。</p>
<p>建议在学习本文的时候从文章尾部的连接中下载完整的示例工程。</p>
<p>下面我将从上面列出的3个重要任务一一进行分解介绍。</p>
<p>这些步骤都是模块化的，所以如果你对界面的绘制不感兴趣，可以跳过<code>绘制用户界面</code>，直接学习后面的步骤。</p>
<p>打开工程文件中的<code>TBCircluarSlider.m</code>文件。然后开始学习下面的内容。</p>
<h4 id="1-1_绘制用户界面">1.1 绘制用户界面</h4>
<p>我比较喜欢使用Core Graphics，唯一用到UIKit的就是通过textfield来显示滑块的值。</p>
<p><code>提醒</code>：此处需要用到一些<code>Core Graphics</code>知识，如果你不懂也没多大关系，我会尽量把代码做详细的讲解。</p>
<p>我们先来看看控件的不同组成部分，这样更有利于后面的学习。</p>
<p>首先，是用一个<code>黑色的圆环</code>当做滑块的背景。</p>
<p><img src="/images/2014/01/13.png" alt=""></p>
<p><code>可操作区域(active area)</code>是一个从蓝色到紫色的梯度渐变效果。</p>
<p><img src="/images/2014/01/14.png" alt=""></p>
<p>用户通过拖拽下面的这个手柄按钮来选择值：</p>
<p><img src="/images/2014/01/15.png" alt=""></p>
<p>最后，用于显示选中值的<code>TextField</code>。在下一版中，我计划让用户可以通过键盘输入角度值。</p>
<p><img src="/images/2014/01/16.png" alt=""></p>
<p>控件界面的绘制主要使用drawRect函数，首选我们需要获取到当前使用的图形上下文，如下代码所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CGContextRef ctx = UIGraphicsGetCurrentContext();</div></pre></td></tr></table></figure>

<h5 id="1-1-1_绘制背景">1.1.1 绘制背景</h5>
<p>背景是360°的，所以只要用CGContextAddArc给图形上下文添加正确的path，并设置正确的stroke即可。</p>
<p>下面的代码可以就可以完成背景的绘制：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Add the arc path</span></div><div class="line">CGContextAddArc(ctx, <span class="keyword">self</span><span class="variable">.frame</span><span class="variable">.size</span><span class="variable">.width</span>/<span class="number">2</span>, <span class="keyword">self</span><span class="variable">.frame</span><span class="variable">.size</span><span class="variable">.height</span>/<span class="number">2</span>, radius, <span class="number">0</span>, M_PI *<span class="number">2</span>, <span class="number">0</span>);</div><div class="line"> </div><div class="line"><span class="comment">//Set the stroke colour</span></div><div class="line">[[<span class="built_in">UIColor</span> blackColor]setStroke];</div><div class="line"> </div><div class="line"><span class="comment">//set Line width and cap</span></div><div class="line">CGContextSetLineWidth(ctx, TB_BACKGROUND_WIDTH);</div><div class="line">CGContextSetLineCap(ctx, kCGLineCapButt);</div><div class="line"> </div><div class="line"><span class="comment">//draw it!</span></div><div class="line">CGContextDrawPath(ctx, kCGPathStroke);</div></pre></td></tr></table></figure>

<p><code>CGContextArc</code>函数的参数包括图形上下文，弧度的中心坐标点，以及半径(是一个私有变量)，接着是弧度开始和结束时的角度(在TBCircularSlider.m文件的头部可以看到一些关于数学计算的方法)，最后一个参数标示绘制的方向，0表示逆时针方向。</p>
<p>接下来的3行的代码是用来设置一些信息的，例如颜色和线条宽度等。最后使用<code>CGContextDrawPath</code>方法完成背景的绘制。</p>
<h5 id="1-1-2_绘制用户的可操作区域">1.1.2 绘制用户的可操作区域</h5>
<p>这部分需要利用一点小技巧才行。此处我们绘制一个线性渐变的掩码图片，下面看看原理：</p>
<p><img src="/images/2014/01/17.png" alt=""></p>
<p>此处掩码图片的工作原理是可以看到原始渐变矩形框的一个孔。</p>
<p>在这里绘制的弧度有一个阴影，这是创建掩码图时使用了一点模糊的效果。</p>
<p>下面是创建掩码图的相关代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">UIGraphicsBeginImageContext(CGSizeMake(<span class="number">320</span>,<span class="number">320</span>));</div><div class="line">CGContextRef imageCtx = UIGraphicsGetCurrentContext();</div><div class="line"> </div><div class="line">CGContextAddArc(imageCtx, <span class="keyword">self</span><span class="variable">.frame</span><span class="variable">.size</span><span class="variable">.width</span>/<span class="number">2</span>  , <span class="keyword">self</span><span class="variable">.frame</span><span class="variable">.size</span><span class="variable">.height</span>/<span class="number">2</span>, radius, <span class="number">0</span>, ToRad(<span class="keyword">self</span><span class="variable">.angle</span>), <span class="number">0</span>);</div><div class="line">[[<span class="built_in">UIColor</span> redColor]set];</div><div class="line"> </div><div class="line"><span class="comment">//Use shadow to create the Blur effect</span></div><div class="line">CGContextSetShadowWithColor(imageCtx, CGSizeMake(<span class="number">0</span>, <span class="number">0</span>), <span class="keyword">self</span><span class="variable">.angle</span>/<span class="number">20</span>, [<span class="built_in">UIColor</span> blackColor]<span class="variable">.CGColor</span>);</div><div class="line"> </div><div class="line"><span class="comment">//define the path</span></div><div class="line">CGContextSetLineWidth(imageCtx, TB_LINE_WIDTH);</div><div class="line">CGContextDrawPath(imageCtx, kCGPathStroke);</div><div class="line"> </div><div class="line"><span class="comment">//save the context content into the image mask</span></div><div class="line">CGImageRef mask = CGBitmapContextCreateImage(UIGraphicsGetCurrentContext());</div><div class="line">UIGraphicsEndImageContext();</div></pre></td></tr></table></figure>

<p>在上面的代码中首先创建了一个图形上下文，然后设置了一下阴影。通过<code>CGContextSetShadowWithColor</code>方法，我们可以设置如下内容：</p>
<ul>
<li>上下文</li>
<li>偏移量(此处不需要)</li>
<li>模糊值(该值是通过参数控制的：使用当前的角度除以20，当用户与此控件交互时，以此获得一个简单的动画模糊值)</li>
<li>颜色</li>
</ul>
<p>接着是根据当前的角度绘制一个相应的弧度。</p>
<p>例如，如果当前的角度变量是360°，那么就绘制一个圆弧，如果是90°，就绘制一个弧度为90°的一个弧。最后，利用<code>CGBitmapContextCreateImage</code>方法获取一张图片（刚刚绘制的弧）。这个图片就是我们所需要的掩码图了。</p>
<p>裁剪上下文：</p>
<p>现在我们已经有一个渐变的掩码图了。接着利用函数<code>CGContextClipToMask</code>对上下文进行裁剪——给该函数传入上面刚刚创建好的掩码图。代码如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CGContextClipToMask(ctx, <span class="keyword">self</span><span class="variable">.bounds</span>, mask);</div></pre></td></tr></table></figure>

<p>最后我们来绘制渐变效果，代码如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Define the colour steps</span></div><div class="line"><span class="built_in">CGFloat</span> components[<span class="number">8</span>] = {</div><div class="line">    <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>,     <span class="comment">// Start color - Blue</span></div><div class="line">    <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span> };   <span class="comment">// End color - Violet</span></div><div class="line"> </div><div class="line">CGColorSpaceRef baseSpace = CGColorSpaceCreateDeviceRGB();</div><div class="line">CGGradientRef gradient = CGGradientCreateWithColorComponents(baseSpace, components, <span class="literal">NULL</span>, <span class="number">2</span>);</div><div class="line"> </div><div class="line"><span class="comment">//Define the gradient direction </span></div><div class="line"><span class="built_in">CGPoint</span> startPoint = CGPointMake(CGRectGetMidX(rect), CGRectGetMinY(rect));</div><div class="line"><span class="built_in">CGPoint</span> endPoint = CGPointMake(CGRectGetMidX(rect), CGRectGetMaxY(rect));</div><div class="line"> </div><div class="line">    <span class="comment">//Choose a colour space</span></div><div class="line">CGColorSpaceRelease(baseSpace), baseSpace = <span class="literal">NULL</span>;    </div><div class="line"> </div><div class="line"><span class="comment">//Create and Draw the gradient</span></div><div class="line">CGContextDrawLinearGradient(ctx, gradient, startPoint, endPoint, <span class="number">0</span>);</div><div class="line">CGGradientRelease(gradient), gradient = <span class="literal">NULL</span>;</div></pre></td></tr></table></figure>

<p>绘制渐变效果需要很多处理，不过我们可以将其分为4部分：</p>
<ul>
<li>定义颜色的变化范围</li>
<li>定义渐变的方向</li>
<li>选择颜色空间</li>
<li>创建并绘制渐变</li>
</ul>
<p>最终的显示效果(看到渐变矩形框的一部分)要归功于之前创建的掩码图。</p>
<p>另外，为了在背景边框模拟光线反射，我添加了一些灯光效果。</p>
<h5 id="1-1-3_绘制手柄">1.1.3 绘制手柄</h5>
<p>下面我们根据当前的角度值，在的正确位置绘制出手柄。</p>
<p>实际上，在绘制过程中，这一步非常简单，复杂一点的就是计算一下手柄所在的位置。</p>
<p>这里我们需要使用三角函数将一个<code>标量值(scalar number)</code>转换为<code>CGPoint</code>。不要担心有多复杂，只需要使用Sin和Cos函数就可以完成。代码如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">-(<span class="built_in">CGPoint</span>)pointFromAngle:(<span class="keyword">int</span>)angleInt{</div><div class="line">     </div><div class="line">    <span class="comment">//Define the Circle center</span></div><div class="line">    <span class="built_in">CGPoint</span> centerPoint = CGPointMake(<span class="keyword">self</span><span class="variable">.frame</span><span class="variable">.size</span><span class="variable">.width</span>/<span class="number">2</span> - TB_LINE_WIDTH/<span class="number">2</span>, <span class="keyword">self</span><span class="variable">.frame</span><span class="variable">.size</span><span class="variable">.height</span>/<span class="number">2</span> - TB_LINE_WIDTH/<span class="number">2</span>);</div><div class="line">     </div><div class="line">    <span class="comment">//Define The point position on the circumference</span></div><div class="line">    <span class="built_in">CGPoint</span> result;</div><div class="line">    result<span class="variable">.y</span> = round(centerPoint<span class="variable">.y</span> + radius * sin(ToRad(-angleInt))) ;</div><div class="line">    result<span class="variable">.x</span> = round(centerPoint<span class="variable">.x</span> + radius * cos(ToRad(-angleInt)));</div><div class="line">     </div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面的代码中，指定一个角度值，然后计算出在圆周上面的位置，当然，这里需要圆周的中心点和半径。</p>
<p>使用sin函数在使用sin函数时，需要一个Y坐标值，而cos函数则需要X坐标值。</p>
<p>需要注意的是此处每个函数返回的值都认为半径为1，所以需要将所得结果乘以我们指定的半径大小，并相对于圆周的中心做计算。</p>
<p>希望下面的公式对你的理解有所帮助：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">point<span class="variable">.y</span> = center<span class="variable">.y</span> + (radius * sin(angle)); </div><div class="line">point<span class="variable">.x</span> = center<span class="variable">.x</span> + (radius * cos(angle));</div></pre></td></tr></table></figure>

<p>通过上面的计算，现在我们已经知道手柄的具体位置了，所以，接下来就直接将手柄绘制到指定位置即可，如下代码所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>) drawTheHandle:(CGContextRef)ctx{</div><div class="line">     </div><div class="line">    CGContextSaveGState(ctx);</div><div class="line">     </div><div class="line">    <span class="comment">//I Love shadows</span></div><div class="line">    CGContextSetShadowWithColor(ctx, CGSizeMake(<span class="number">0</span>, <span class="number">0</span>), <span class="number">3</span>, [<span class="built_in">UIColor</span> blackColor]<span class="variable">.CGColor</span>);</div><div class="line">     </div><div class="line">    <span class="comment">//Get the handle position!</span></div><div class="line">    <span class="built_in">CGPoint</span> handleCenter =  [<span class="keyword">self</span> pointFromAngle: <span class="keyword">self</span><span class="variable">.angle</span>];</div><div class="line">     </div><div class="line">    <span class="comment">//Draw It!</span></div><div class="line">    [[<span class="built_in">UIColor</span> colorWithWhite:<span class="number">1.0</span> alpha:<span class="number">0.7</span>]set];</div><div class="line">    CGContextFillEllipseInRect(ctx, CGRectMake(handleCenter<span class="variable">.x</span>, handleCenter<span class="variable">.y</span>, TB_LINE_WIDTH, TB_LINE_WIDTH));</div><div class="line">     </div><div class="line">    CGContextRestoreGState(ctx);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>具体操作步骤如下：</p>
<ul>
<li>保存当前的上下文(当在一个单独的函数中进行绘制任务时，将上下文的状态进行保存是编程的一个好习惯)。</li>
<li>给手柄设置一些阴影效果</li>
<li>定义手柄的颜色，然后利用<code>CGContextFillEllipseInRect</code>将其绘制出来。</li>
</ul>
<p>我们在drawRect函数的最后调用上面这个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span> drawTheHandle:ctx];</div></pre></td></tr></table></figure>

<p>至此，我们就完成了绘制部分的任务。</p>
<h4 id="1-2_跟踪用户的操作">1.2 跟踪用户的操作</h4>
<p>在UIControl的子类中，我们可以<code>override</code>3个特殊的方法来提供一个自定义的跟踪行为</p>
<h5 id="1-2-1_开始跟踪">1.2.1 开始跟踪</h5>
<p>当在控件的bound内发生了一个触摸事件，首先会调用控件的<code>beginTrackingWithTouch</code>方法。</p>
<p>我们就看看如何<code>override</code>这个方法吧：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">-(<span class="built_in">BOOL</span>)beginTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event{</div><div class="line">    [<span class="keyword">super</span> beginTrackingWithTouch:touch withEvent:event];</div><div class="line"> </div><div class="line">    <span class="comment">//We need to track continuously</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>该函数返回的BOOl值决定着：当触摸事件是dragged时，是否需要响应。在我们这里的自定义控件中，是需要跟踪用户的dragging，所以返回YES。</p>
<p>上面这个函数有两个参数：touch对象和事件。</p>
<h5 id="1-2-2_持续跟踪">1.2.2 持续跟踪</h5>
<p>在上一个方法中我们指定了这里的自定义控件需要跟踪一个持续的事件，所以当用户进行drag时，会调用一个特殊的方法：<code>continueTrackingWithTouch</code>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-(<span class="built_in">BOOL</span>)continueTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event</div></pre></td></tr></table></figure>

<p>该方法返回的BOOL值标示是否继续跟踪touch事件。</p>
<p>通过该方法我们可以根据touch位置对用户的操作进行过滤。例如，我们可以：仅当touch位置与手柄位置相交的时候才激活控件(activate control)。不过在这里我们的控制逻辑并不是这样的，我们希望用户点击任何位置都能对手柄做出相应的位置处理。</p>
<p>本文的该方法负责更新手柄的位置(在后面的一节中会看到我们把该位置信息传递给对应的target上)。</p>
<p>对上面这个方法的override代码如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">-(<span class="built_in">BOOL</span>)continueTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event{</div><div class="line">    [<span class="keyword">super</span> continueTrackingWithTouch:touch withEvent:event];</div><div class="line"> </div><div class="line">    <span class="comment">//Get touch location</span></div><div class="line">    <span class="built_in">CGPoint</span> lastPoint = [touch locationInView:<span class="keyword">self</span>];</div><div class="line"> </div><div class="line">    <span class="comment">//Use the location to design the Handle</span></div><div class="line">    [<span class="keyword">self</span> movehandle:lastPoint];</div><div class="line"> </div><div class="line">        <span class="comment">//We'll see this function in the next section:</span></div><div class="line">    [<span class="keyword">self</span> sendActionsForControlEvents:UIControlEventValueChanged];</div><div class="line"> </div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面的代码中，首先利用<code>locationInView</code>获取到touch的位置，然后将该位置传递给<code>moveHandle</code>方法，该方法会将传入的值转换为一个有效的手柄位置(a valid handle position)。</p>
<p>此处“a valid position”的意思是什么呢？</p>
<p>此控件的手柄只能在背景圆弧定义的边界范围内做移动，但是我们不希望强制要求用户必须在很小的圆弧内才可以移动手柄，如果非要这样的话，用户体验会非常的糟糕。</p>
<p><code>moveHandle</code>的任务就是负责把任意的位置值转变为手柄可移动的值，另外，另外，在该函数中，还对指定的滑块角度值做了转换，代码如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)movehandle:(<span class="built_in">CGPoint</span>)lastPoint{</div><div class="line">     </div><div class="line">    <span class="comment">//Get the center</span></div><div class="line">    <span class="built_in">CGPoint</span> centerPoint = CGPointMake(<span class="keyword">self</span><span class="variable">.frame</span><span class="variable">.size</span><span class="variable">.width</span>/<span class="number">2</span>,</div><div class="line">                                                                            <span class="keyword">self</span><span class="variable">.frame</span><span class="variable">.size</span><span class="variable">.height</span>/<span class="number">2</span>);</div><div class="line">     </div><div class="line">    <span class="comment">//Calculate the direction from the center point to an arbitrary position.</span></div><div class="line">    <span class="keyword">float</span> currentAngle = AngleFromNorth(centerPoint, </div><div class="line">                                                                                lastPoint, </div><div class="line">                                                                                <span class="literal">NO</span>);</div><div class="line">    <span class="keyword">int</span> angleInt = floor(currentAngle);</div><div class="line">     </div><div class="line">    <span class="comment">//Store the new angle</span></div><div class="line">    <span class="keyword">self</span><span class="variable">.angle</span> = <span class="number">360</span> - angleInt;</div><div class="line"> </div><div class="line">    <span class="comment">//Update the textfield </span></div><div class="line">    _textField<span class="variable">.text</span> =  [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%d"</span>, </div><div class="line">                                                                                                    <span class="keyword">self</span><span class="variable">.angle</span>];</div><div class="line">     </div><div class="line">    <span class="comment">//Redraw</span></div><div class="line">    [<span class="keyword">self</span> setNeedsDisplay];</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上面代码中，实际上主要任务都是在<code>AngleFromNorth</code>方法中处理的：根据两个point，就会返回一个连接这两点对应的一个角度关系，<code>AngleFromNorth</code>方法的实现如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">float</span> AngleFromNorth(<span class="built_in">CGPoint</span> p1, <span class="built_in">CGPoint</span> p2, <span class="built_in">BOOL</span> flipped) {</div><div class="line">    <span class="built_in">CGPoint</span> v = CGPointMake(p2<span class="variable">.x</span>-p1<span class="variable">.x</span>,p2<span class="variable">.y</span>-p1<span class="variable">.y</span>);</div><div class="line">    <span class="keyword">float</span> vmag = sqrt(SQR(v<span class="variable">.x</span>) + SQR(v<span class="variable">.y</span>)), result = <span class="number">0</span>;</div><div class="line">    v<span class="variable">.x</span> /= vmag;</div><div class="line">    v<span class="variable">.y</span> /= vmag;</div><div class="line">    <span class="keyword">double</span> radians = atan2(v<span class="variable">.y</span>,v<span class="variable">.x</span>);</div><div class="line">    result = ToDeg(radians);</div><div class="line">    <span class="keyword">return</span> (result &gt;=<span class="number">0</span>  ? result : result + <span class="number">360.0</span>);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>提醒：<code>angleFromNorth</code>方法并不是我的原创，我是直接从苹果提供的OSX示例clockControl中拿过来用的。</p>
<p>在上面的代码中，获得了角度值以后，将其存储到<code>angle</code>中，然后更新一下textfield的值。</p>
<p>接着调用的<code>setNeedDisplay</code>是为了确保<code>drawRect</code>被调用，以尽快在界面上做出相应的更新。</p>
<h5 id="1-2-3_结束跟踪">1.2.3 结束跟踪</h5>
<p>当跟踪结束的时候，会调用下面这个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)endTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event{</div><div class="line">    [<span class="keyword">super</span> endTrackingWithTouch:touch withEvent:event];</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在本文中，我们并不需要override该方法。如果当用户完成控件的界面操作时，你希望做一些处理，那么该方法会非常有用。</p>
<h4 id="1-3_Target-Action模式">1.3 Target-Action模式</h4>
<p>至此，圆形滑块控件可以工作了，你可以drag手柄，并能看到textfield中值的改变。</p>
<p>发送action——控件事件</p>
<p>如果希望自己定制的控件与UIControl行为保持一致，那么当控件的值发生变化时，需要进行通知处理：使用<code>sendActionsForControlEvents</code>方法，并制定特定的事件类型，值改变对应的事件一般是<code>UIControlEventValueChanged</code>。</p>
<p>苹果已经预定义了许多事件类型(Xcode中，在UIControlEventValueChanged上<code>cmd + 鼠标单击</code>)。如果你的控件是继承自UITextField，那么你可能会对<code>UIControlEventEdigitingDidBegin</code>感兴趣，如果你要做一个touch Up action，那么可以使用UIControlTouchUpInside。</p>
<p>如果你注意的话，在本文前部分的continueTrackingWithTouch方法里面，我们调用了<code>sendActionsForControlEvents</code>方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span> sendActionsForControlEvents:UIControlEventValueChanged];</div></pre></td></tr></table></figure>

<p>这样处理之后，当控件值发生变化时，每一个对象(观察者——注册该事件)都会收到响应的通知。</p>
<h3 id="2-_如何使用自定义控件">2. 如何使用自定义控件</h3>
<p>到这里，我们的控件定制完毕，下面介绍如何在程序中使用自定义的控件。</p>
<p>打开文件<code>TBViewController.m</code>，看看<code>viewDidLoad</code>方法里面的代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad</div><div class="line">{</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> colorWithRed:<span class="number">0.1</span> green:<span class="number">0.1</span> blue:<span class="number">0.1</span> alpha:<span class="number">1</span>];</div><div class="line">     </div><div class="line">    <span class="comment">//Create the Circular Slider</span></div><div class="line">    TBCircularSlider *slider = [[TBCircularSlider alloc]initWithFrame:CGRectMake(<span class="number">0</span>, <span class="number">60</span>, TB_SLIDER_SIZE, TB_SLIDER_SIZE)];</div><div class="line">     </div><div class="line">    <span class="comment">//Define Target-Action behaviour</span></div><div class="line">    [slider addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(newValue:) forControlEvents:UIControlEventValueChanged];</div><div class="line">     </div><div class="line">    [<span class="keyword">self</span><span class="variable">.view</span> addSubview:slider];</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在上面的代码中，给view设置了一个背景色，并通过调用<code>initWithFrame</code>方法实例化了一个圆形滑块(自定义的控件)。</p>
<p>注意：UIControl继承自UIView，所以它继承了UIView的所有方法。</p>
<p>接着定义了如何与该控件进行交互：使用<code>addTarget:action:forControlEvent:</code>方法。</p>
<p>该方法只是给控件的特定事件设置一下target-action。如果你还记得的话，上面层介绍过，每当用户移动手柄时，圆形滑块都会发送一个UIControlEventValueChanged事件。所以我们可以通过下面的代码为该事件注册一个action：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[slider addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(newValue:) forControlEvents:UIControlEventValueChanged];</div></pre></td></tr></table></figure>

<p>这样我们就可以创建一个<code>**newValue**</code>方法来处理值发生改变时的一些事情：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)newValue:(TBCircularSlider*)slider{</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Slider Value %d"</span>,slider<span class="variable">.angle</span>);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>结合Target-Action，所以函数会受到action的发送者，此处是slider，通过这个slider，就能直接获取到角度值。</p>
<h3 id="3-_总结">3. 总结</h3>
<p>根据本文的具体步骤，你可以构建<code>任意你想要的控件</code>。</p>
<p>当然，也有其它一些方法来构建自定控件，不过本文基本上是按照苹果的建议来做的。</p>
<p>点击下图，下载代码</p>
<h3 id="4-_代码下载">4. 代码下载</h3>
<p><a href="https://github.com/ariok/TB_CircularSlider" target="_blank" rel="external"><img src="/images/2013/11/34.jpg" alt=""></a></p>
<p>本文由破船译自<a href="http://www.thinkandbuild.it/how-to-build-a-custom-control-in-ios/" target="_blank" rel="external">How to build a custom control in iOS</a>。大家要是有什么问题，可以直接在<a href="https://twitter.com/bitwaker" target="_blank" rel="external">twitter</a>上联系原作者，当然也可以在下面的评论中回复我。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="/images/2014/01/18.png" alt=""></p>
]]>
    
    </summary>
    
      <category term="iOS探索" scheme="http://beyondvincent.com/categories/iOS%E6%8E%A2%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我写的第一本书：Windows 8开发实战体验]]></title>
    <link href="http://beyondvincent.com/2014/01/16/2014-01-16-for-my-first-book/"/>
    <id>http://beyondvincent.com/2014/01/16/2014-01-16-for-my-first-book/</id>
    <published>2014-01-16T09:55:00.000Z</published>
    <updated>2014-12-31T19:05:45.000Z</updated>
    <content type="html"><![CDATA[<p><img src="/images/2014/01/9.png" alt=""></p>
<a id="more"></a>

<p>2013年我写了一本书，书名叫做<a href="http://www.amazon.cn/dp/B00EOF7XKC" target="_blank" rel="external">Windows 8开发实战体验</a>。在刚开始写该书的时候，我对Windows 8的前景还是看好的，每天经常写到半夜2-3点中。但是等书写完，出版出来的时候，我的心情确高兴不起来，因为此时大家都知道，windows 8不足以与iOS和Android抗衡，好多开发者都不看好它了，自然也就不在这方面发力。</p>
<p>还记得2012年下半年的时候，国内还是有许多开发者投入Windows 8的，不过到现在，基本已经没什么了。不知道Windows 8怎么了。是否值得期待Windows 9呢？</p>
<p>每当大家问起这书的销量时，我在想，Windows 8都这样了，还有人舍得去投资吗？估计对Windows 8的投入，也就是大公司为了各自产品的布局而没有舍弃的了。</p>
<p>如果你希望支持我一下的话，也可以去<a href="http://www.amazon.cn/dp/B00EOF7XKC" target="_blank" rel="external">亚马逊</a>上买几本哟。</p>
<p>惯例，上几张图片：</p>
<p><img src="/images/2014/01/11.png" alt=""></p>
<p>下面是公司内刊《云电同方人》曾经对我的一个采访函，贴出来，就当纪念吧：</p>
<p>采访人物： 周智勋</p>
<p>采访问题：</p>
<p>1、    为什么会写这本书？写作的主要灵感源于何处？</p>
<p><code>其实本书涉及到的许多内容首先是发布到我博客中的，后来随着文章数量的增加，就有了出版的想法，进而开始跟出版社沟通相关事情。</code></p>
<p>2、    全书从酝酿到出版，总共花费了多久的时间？能否具体谈谈这个过程</p>
<p><code>从跟出版社约谈，到最终出版大约花了半年时间。其中大致经历了大纲制定、初稿编写、初审、二审和终审，以及下厂编册。</code></p>
<p>3、    作为技术性人才，很多人在写作这一方面并非特别擅长，那么在写这本书的过程有没有让你困扰的地方？</p>
<p><code>其实我也不擅长写作，很难做到胸有成竹，一直在想许多名著是如何写成的。后来慢慢的发现，日积月累真是个好词，许多事情都不是一蹴而就的。坚持了不一定成功，但是不坚持，一定不会成功。</code></p>
<p>4、    在这一过程中，有没有特别想要感谢的人？</p>
<p><code>当然要感谢我的家人和同事对我的技术支持和人文关怀</code></p>
<p>5、    这本书的完成对于你个人、团队、公司的意义分别是怎样的？</p>
<p><code>这本书对于我来说就是成长路上的一抹云彩，点缀了我的工作与生活，增加我人生阅历。由于公司和团队的良好氛围，让我能够得到茁壮成长，相信在这良好的土壤下，能够培养出更多、更优秀的人才。</code></p>
<p>6、    平时有没有什么兴趣爱好？你觉得这样的兴趣爱好对于你的工作和生活有什么影响吗？</p>
<p><code>跑步是我近些年养成的一个习惯。我不知道是不是真的喜欢跑步，因为在篮球和跑步面前，我几乎都会首选篮球。不过我享受跑步带给我的变化，在跑步沿途中不仅能欣赏到各种风景，还能让我身体健康。</code></p>
<p>7、    对你影响最大的一本书是什么？</p>
<p><code>谭浩强的《C程序设计》，是它让我踏上了IT这条不归路。</code></p>
<p>8、    能完成这样一本技术专著，可以说在IT业界也取得了一定成就，你有没有什么心得想与他人分享的？</p>
<p><code>成就谈不上，我只是沧海一粟。想跟大家说的一句话就是“坚持就有收获。</code></p>
<p>9、    对于现在很多刚入职或者已入职一段时间的IT人士深觉IT行业枯燥、乏味，你怎么看待？你能理解他们吗？</p>
<p><code>兴趣是最好的老师。当你对某件事情感兴趣，那么就会主动去接触它，了解它。如果觉得IT行业枯燥和乏味，最好的办法就是培养兴趣或者乘早转行。</code></p>
<p>10、 你个人觉得IT行业未来的发展趋势是怎样的？</p>
<p><code>这个话题有点hold不住！仅从个人角度来看，移动技术、智能客厅、物流整合、大数据和人工智能等都很有发展前景。</code></p>
<p>2014年我计划写一本iOS 8方面的书籍，按照惯例，要等到6月份苹果才会对开发者放出iOS 8的SDK，所以上半年主要做一些准备性的任务。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="/images/2014/01/9.png" alt=""></p>
]]>
    
    </summary>
    
      <category term="Windows 8" scheme="http://beyondvincent.com/categories/Windows-8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[迟到的Windows 8]]></title>
    <link href="http://beyondvincent.com/2014/01/15/2013-12-17-127-my-book-windows-8-developer/"/>
    <id>http://beyondvincent.com/2014/01/15/2013-12-17-127-my-book-windows-8-developer/</id>
    <published>2014-01-15T04:18:00.000Z</published>
    <updated>2014-12-31T19:05:45.000Z</updated>
    <content type="html"><![CDATA[<p><img src="/images/2013/12/26.png" alt=""></p>
<a id="more"></a>

<p>目录</p>
<ol>
<li>小引</li>
<li>Windows 8简介</li>
<li>从用户的角度来看</li>
<li>从开发者的角度来看</li>
<li>微软的生态圈</li>
<li>小结</li>
</ol>
<h3 id="小引">小引</h3>
<p>最近两年，移动互联网成了兵家必争之地，为了能够在移动互联网的浪潮中获得一席之地，各厂商正所谓八仙过海各显神通，腾讯首当其中，通过微信拿到了第一张船票，百度19亿美元拿下91助手，豪赌移动互联网，阿里巴巴入主高德，加快移动互联网布局，雷军借助小米手机，在国内已经与”中华酷联”并驾齐驱。当然，有成功，必然有失败，诺基亚本想借助微软的Windows Phone重拾当年王者之位，哪知最后埃洛普就是一个”间谍”，在诺基亚市值触底之际，反被微软低价收购，360与搜狗的恋爱谈了很久，结局是搜狗与腾讯联姻了。</p>
<p>在这瞬息万变的朝代，人们似乎已经忘却了微软，其实微软对这一切的发生是看在眼里急在心里，但罗马不是一日建成的。今天我们就来看看微软在移动平台中打的一张牌——Windows 8。</p>
<h3 id="Windows_8简介">Windows 8简介</h3>
<p>Windows 8是微软在2012年10月25日正式发布的一款操作系统。该系统定义了用户与移动终端设备交互的全新概念——以内容为导向，结合简单、迅速和快捷的操作方式。</p>
<p><img src="/images/2013/12/17.png" alt="图1-1 Windows 8开始屏幕"></p>
<p>为迎合用户的需求，微软在Windows 8的设计与研发上全力以赴，力图为用户打造出一款全新的操作系统，为人们提供高效易行的工作环境。从图1-1中，可以明显地感觉到Windows 8的用户界面与之前Windows版本的巨大差别。</p>
<p>下面我们分别从用户和开发者的角度来了解一下Windows 8。</p>
<h3 id="从用户的角度来看">从用户的角度来看</h3>
<ol>
<li>磁贴</li>
</ol>
<p>Windows 8的开始屏幕功能与之前Windows 版本的开始菜单类似，都是能启动某一个程序，不过开始屏幕还有更多的个性化功能。如图1-2所示，Windows 8的开始屏幕是由许多方块组成的，这些方块被称为动态磁贴(Tile)，用户可以自由调整这些方块的大小。通过点击磁贴，可以启动对应的程序。磁贴的另外一个重要功能就是内容的展现与更新。这体现出了Windows 8的一个重要设计原则—— 处处以内容为重。</p>
<p><img src="/images/2013/12/18.png" alt="图1-2 Windows 8开始屏幕中的磁贴"></p>
<ol>
<li>沉浸式的用户界面</li>
</ol>
<p>Windows 8之前版本的基本用户界面如图1-3所示，是以桌面为主的应用程序界面风格——该类风格的典型特征是操作系统由不同的文件和程序软件组成。在桌面之上，可以陈列出多个窗口，一个程序对应一个窗口，或者多个窗口。</p>
<p><img src="/images/2013/12/19.png" alt="图1-3 具有桌面概念的应用程序界面"></p>
<p>Windows 8应用商店的主界面如图1-4所示，可以看出，里面的程序像一个封闭的盒子，并且是没有边框的全屏显示，我们只能看到一个正在运行的程序界面。实际上，这种设计语言和风格是微软专门为Windows 8配备的，它是基于平面设计的，设计灵感来源于机场和地铁的指示牌。图1-4展现的信息可以概括为：大字体、强调信息本身、无冗余的界面元素。</p>
<p><img src="/images/2013/12/20.png" alt="图1-4 Windows 8应用商店的主界面"></p>
<p>再如图1-5所示的是Windows 8中的天气程序，该程序以大号字体显示出天气信息，在程序中没有冗余的界面元素。</p>
<p><img src="/images/2013/12/21.png" alt="图1-5 Windows 8中的天气程序"></p>
<p>从图1-4和图1-5可以明显地感觉到，当用户使用Windows 8商店应用程序时，是完全沉浸在整个程序中，且在使用过程中，不会被别的程序干扰或者强制中断，从而不会对用户造成任何的分心。</p>
<h3 id="从开发者的角度来看">从开发者的角度来看</h3>
<ol>
<li>Windows应用商店</li>
</ol>
<p>从苹果做的应用商店效果来看，这真是一个好舞台，个人开发者通过这个舞台发布个人应用的同时，还能带来乐观收入，苹果也能从中收取一定的费用，再者对用户来说不用漫天寻找需要的应用，只需要通过应用商店就可以获得需要的应用了。</p>
<p>当然，微软也搭建了自己的商店——Windows应用商店，运营模式与苹果的应用商店类似。如图1-6所示。</p>
<p><img src="/images/2013/12/22.png" alt="图1-6 开始屏幕中的应用商店"></p>
<p>到这里，或许大家对微软的这张牌已经有所了解，更有甚者可能会嗤之以鼻，曰：这不就是在抄袭苹果的模式吗？没错，微软此举确有抄袭之嫌疑，不过，大家别忘了，腾讯刚开始不就是这么干的吗？当然，干这一行，是讲究互联网基因的，例如，中国移动的飞信就是因为缺乏互联网基因——它并不具备运营互联网产品的基本经验，虽手握绝对优势，但最终未免被其它IM蚕食，再说了，诺基亚之前也有自己的OVI商店，但是结果同样销声匿迹了。</p>
<ol>
<li>开发框架与编程语言</li>
</ol>
<p>Windows 8商店应用程序开发支持多种编程语言，其中最重要的3种编程方式为：XAML + C#/VB、XAML/DirectX + C++、HTML5 + JS + CSS。 </p>
<p>Windows 8对多种编程语言的支持，降低了开发者开发Windows 8商店应用程序的门槛，开发者可以利用之前已经掌握的语言来开发程序。</p>
<p>1）开发框架</p>
<p>在Windows 8中开发的应用程序分为两种类型：</p>
<ul>
<li>Windows商店应用程序</li>
<li>桌面应用程序</li>
</ul>
<p>其中桌面应用程序与之前Windows版本中的开发模式基本没有变化，这里重点介绍Windows商店应用程序的开发框架(如图1-7所示)，它具有如下两个重要特点：</p>
<p><img src="/images/2013/12/23.png" alt="图1-7 Windows 8应用程序开发框架"></p>
<ul>
<li><p>Windows Runtime。在Windows商店应用程序中只有一个主要的API层，这就是Windows Runtime，Windows Runtime负责与Windows Core OS Services进行通讯。开发者只需要与Windows Runtime交互即可。</p>
</li>
<li><p>多语言的支持。Windows商店应用程序开发很重要的一个特点就是在一个编程API（Windows Runtime APIs）上对多种语言的支持。在Windows 8中，微软已经把基于WPF和Silverlight的XAML用本地语言重写了一遍，C++、C、C#和VB编写的应用程序UI界面可以用XAML来定义。另外，在Windows 8中，微软增强了JavaScript的功能，通过JS Engine，JavaScript可以与Windows Runtime提供的APIs进行交互。这样一来，众多开发者（特别是会利用HTML和CSS开发网站和网页的开发者）也可以结合HTML/CSS和JavaScript来开发Windows商店应用程序。</p>
</li>
</ul>
<p>2）编程语言选择</p>
<p>由于Windows 8应用程序开发支持多种编程语言，那么在具体的开发过程中，开发者就需要在多种编程语言之间选择适合的一种。图1-8简要描述了如何选择编程语言。</p>
<p><img src="/images/2013/12/24.png" alt="图1-8 Windows商店应用程序开发编程语言的选择"></p>
<p>一般在创建应用程序时，是基于开发者已经掌握的技术；如果是在移植已有的应用程序，则主要基于原有程序的类型。<br>下面是在选择编程语言时需要注意的一些细节：</p>
<ul>
<li>根据开发者已经掌握的技术做决定。如果擅长于JavaScript，那么建议选择HTML5和JavaScript作为编程语言。如果之前创建过Windows Phone程序或者WPF程序，那么使用C#/VB和XAML语言进行开发会更好。</li>
<li>在决定移植程序时，则需要好好考虑一番。这种情况下，不能依赖所掌握的技术，而主要取决于将要移植的程序的类型。如果要将Windows Phone(Windows Phone 8以前的版本)程序进行移植，那么必须选择使用C#和XAML，这样之前的代码和功能才能重用，如果Windows Phone程序使用了类似MVVM的设计模式，那么可以在程序中使用对应的设计模式。而如果需要移植基于C++开发的游戏引擎等，就需要使用C++和XAML了。</li>
<li>如果既掌握web开发，也熟悉C#  XAML开发，那么建议使用HTML5和JavaScript进行程序开发。因为JS Engine提供的控件与XAML控件一样，不用额外去编写控件。</li>
<li>如果要创建高效的游戏程序，那么建议考虑使用C++和XAML。</li>
<li>如果曾是.NET开发者，并且也熟练掌握HTML和JavaScript，建议使用C#和XAML。开发程序时会发现，这与.NET开发非常相似。例如，可以使用相同的设计模式（例如MVVM等）来创建程序。</li>
</ul>
<p>通过上面的分析，相信在开发过程中应该如何在开发中选择编程语言，读者已经心中有数了。下面我们来看看微软的生态圈。</p>
<h3 id="微软的生态圈">微软的生态圈</h3>
<p>在互联网环境中，良好的生态圈，对企业的发展至关重要，腾讯在社交上、百度在搜索上和阿里在电商上等能站稳脚，都是因为他们在各自的阵营中建立起了良性的生态圈，让对此垂涎的企业难以对其撼动。我们也可以来看看苹果创建的生态圈：为了给用户最佳的体验，从硬件到软件，苹果层层把控，对别的厂商进行封闭不开放，利用自己的优势，为开发者和用户提供一个应用发布销售和购买下载的大舞台——苹果应用商店。这不仅让自己的利益最大化，也能够极好“绑架”开发者和用户，并对其它厂商做到排斥。</p>
<p><img src="/images/2013/12/25.png" alt="图1-8 Windows商店应用程序开发编程语言的选择"></p>
<p>说了这么多，读者可能不乐意了，你不是要谈论微软的生态圈吗，干嘛东扯西扯的呢？其实不然，微软在生态圈上的想法实际上跟苹果雷同。涉及到的几个主体无非就是开发者、用户和自己，另外与苹果有一大区别就是其它厂商。我们都知道，微软在Windows 8之前主打的是软件，硬件则由其它各厂商生产。而在Windows 8中则不同了，微软开始涉水硬件了，它也想像苹果一样把软件和硬件牢牢握在自己手中，因此Surface面世了，再过几天Surface2也可以预定到了。其实我并不关心什么时候能买到Surface2，我在意的是微软如何找准与各硬件厂商的利益平衡点。 </p>
<h3 id="小结">小结</h3>
<p>Windows 8发布至今(2014年1月)，过去一年多了，或许你在感悟时间过得太快，但我想说，Windows 8来得太迟了，要不是Windows 8有这么强大的一个爹，在这战火纷飞的移动平台，想必Windows 8还没开始就已经谢幕了。</p>
<p>在这一年时间里，我们看到Windows 8交出的成绩其实并不如人意，想必用惨不忍睹来形容也不为过。用户和开发者的热衷度已经在大幅下降，甚至各厂商都在持观望的态度，相信他们都是有底线的。至于Windows 8操作系统能否在众多竞争平台中突出重围，留给微软的时间已经不多了，随着PC市场趋于饱和，在移动平台上，如果微软再拿不出杀手锏的话，或许微软真要重演诺基亚的悲剧了。 </p>
<p>当然，移动互联网的这番厮杀与角逐，无论谁赢谁输，我相信最大的获益者之一将会是用户。作为用户，我们就在台下，好好欣赏这一幕幕好戏吧！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="/images/2013/12/26.png" alt=""></p>
]]>
    
    </summary>
    
      <category term="Windows 8" scheme="http://beyondvincent.com/categories/Windows-8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[给tableview cell添加动画]]></title>
    <link href="http://beyondvincent.com/2014/01/13/2014-01-13-animation-tableview-cell/"/>
    <id>http://beyondvincent.com/2014/01/13/2014-01-13-animation-tableview-cell/</id>
    <published>2014-01-13T09:30:00.000Z</published>
    <updated>2014-12-31T19:05:45.000Z</updated>
    <content type="html"><![CDATA[<p><img src="/images/2014/01/5.png" alt=""></p>
<a id="more"></a>

<h3 id="小引">小引</h3>
<p>本文介绍如何利用给tableview cell添加动画。其实只需要很少的代码量就可以。本文参考<a href="http://www.thinkandbuild.it/animating-uitableview-cells/" target="_blank" rel="external">Animating UITableView cells</a></p>
<p>下面先来看看最终的效果：</p>
<iframe height="498" width="510" src="http://player.youku.com/embed/XNjYxMTgxOTQw" frameborder="0" allowfullscreen></iframe>

<p>从上面的视频中，可以看出，当cell显示出来的时候，是在Y和Z轴上进行3D旋转。</p>
<p>下面来看看是如何实现的：</p>
<p>首先假设你已经能够熟练使用UITableView了。那么我们只需要实现UITableViewDelegate中的tableView:WillDisplayCell:ForRowAtIndexPath:即可。当cell显示之前，会先调用该方法，因此给cell添加动画，在这个方法里面即可。</p>
<p>如下代码所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)tableView:(<span class="built_in">UITableView</span> *)tableView willDisplayCell:(<span class="built_in">UITableViewCell</span> *)cell forRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath{</div><div class="line">    <span class="comment">// 1. 配置CATransform3D的内容</span></div><div class="line">    CATransform3D transform;</div><div class="line">    transform = CATransform3DMakeRotation( (<span class="number">90.0</span>*M_PI)/<span class="number">180</span>, <span class="number">0.0</span>, <span class="number">0.7</span>, <span class="number">0.4</span>);</div><div class="line">    transform<span class="variable">.m34</span> = <span class="number">1.0</span>/ -<span class="number">600</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// 2. 定义cell的初始状态</span></div><div class="line">    cell<span class="variable">.layer</span><span class="variable">.shadowColor</span> = [[<span class="built_in">UIColor</span> blackColor]CGColor];</div><div class="line">    cell<span class="variable">.layer</span><span class="variable">.shadowOffset</span> = CGSizeMake(<span class="number">10</span>, <span class="number">10</span>);</div><div class="line">    cell<span class="variable">.alpha</span> = <span class="number">0</span>;</div><div class="line">    </div><div class="line">    cell<span class="variable">.layer</span><span class="variable">.transform</span> = transform;</div><div class="line">    cell<span class="variable">.layer</span><span class="variable">.anchorPoint</span> = CGPointMake(<span class="number">0</span>, <span class="number">0.5</span>);</div><div class="line">    </div><div class="line">    <span class="comment">// 3. 定义cell的最终状态，并提交动画</span></div><div class="line">    [<span class="built_in">UIView</span> beginAnimations:<span class="string">@"transform"</span> context:<span class="literal">NULL</span>];</div><div class="line">    [<span class="built_in">UIView</span> setAnimationDuration:<span class="number">0.5</span>];</div><div class="line">    cell<span class="variable">.layer</span><span class="variable">.transform</span> = CATransform3DIdentity;</div><div class="line">    cell<span class="variable">.alpha</span> = <span class="number">1</span>;</div><div class="line">    cell<span class="variable">.layer</span><span class="variable">.shadowOffset</span> = CGSizeMake(<span class="number">0</span>, <span class="number">0</span>);</div><div class="line">    cell<span class="variable">.frame</span> = CGRectMake(<span class="number">0</span>, cell<span class="variable">.frame</span><span class="variable">.origin</span><span class="variable">.y</span>, cell<span class="variable">.frame</span><span class="variable">.size</span><span class="variable">.width</span>, cell<span class="variable">.frame</span><span class="variable">.size</span><span class="variable">.height</span>);</div><div class="line">    [<span class="built_in">UIView</span> commitAnimations];</div><div class="line">}</div></pre></td></tr></table></figure>

<p>第一步：使用CATransform3D在Y和Z轴上做旋转设置。</p>
<p>第二步：定义cell的初始状态，添加了一些阴影，并将第一步中的transform设置给cell中layer的transform matrix。然后将anchor设置为0.0, 0.5，也就是说让cell围绕着左边进行旋转。</p>
<p>第三步：通过动画，将cell设置为原始状态。此处利用了UIView的beginAnimations:context方法来更新cell中layer的值。当然还有别的方法来执行动画，不过这种方法比较简单，我们可以设置持续时间。代码里面将transform设置为CATransform3DIdentity。</p>
<p>这样通过第二步和第三步的状态就能够引导动画，以此完成最终效果。</p>
<p>完整代码工程下载地址：<br><a href="https://github.com/BeyondVincent/BVTableViewAnimation" target="_blank" rel="external">BVTableViewAnimation</a></p>
<p>下面是网上看到的两个内容，可以参考：</p>
<p><a href="http://www.raywenderlich.com/49311/advanced-table-view-animations-tutorial-drop-in-cards" target="_blank" rel="external">From RW：Table View Animations Tutorial: Drop-In Cards</a><a href="http://weibo.com/522056706" target="_blank" rel="external"><code>@bluesea哈哈哈</code></a>推荐本链接</p>
<p><a href="http://maniacdev.com/2013/05/library-allowing-you-to-create-table-views-with-wacky-highly-detailed-ripple-cell-animations" target="_blank" rel="external">Library Allowing You To Create Table Views With Wacky Highly Detailed Ripple Cell Animations
</a></p>
<p><a href="http://maniacdev.com/2012/05/drop-in-open-source-library-for-creating-wacky-animated-uitableviews" target="_blank" rel="external">Drop-In Open Source Library For Creating Wacky Animated UITableViews</a></p>
<p>希望上面介绍对你有帮助，如果有问题，可以在下面的回复我。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="/images/2014/01/5.png" alt=""></p>
]]>
    
    </summary>
    
      <category term="iOS探索" scheme="http://beyondvincent.com/categories/iOS%E6%8E%A2%E7%B4%A2/"/>
    
  </entry>
  
</feed>
